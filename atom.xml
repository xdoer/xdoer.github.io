<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aiyou.life</id>
    <title>文享日志</title>
    <updated>2021-06-02T06:15:56.911Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aiyou.life"/>
    <link rel="self" href="https://aiyou.life/atom.xml"/>
    <logo>https://aiyou.life/images/avatar.png</logo>
    <icon>https://aiyou.life/favicon.ico</icon>
    <rights>All rights reserved 2021, 文享日志</rights>
    <entry>
        <title type="html"><![CDATA[写一个倒计时😢？]]></title>
        <id>https://aiyou.life/post/iWhkaOqqO/</id>
        <link href="https://aiyou.life/post/iWhkaOqqO/">
        </link>
        <updated>2021-06-01T08:20:34.000Z</updated>
        <summary type="html"><![CDATA[<p>如何写一个高性能、易扩展、易用的计时器？</p>
]]></summary>
        <content type="html"><![CDATA[<p>如何写一个高性能、易扩展、易用的计时器？</p>
<!-- more -->
<p>某日，接到了产品需求，说要加一个抢购列表页面，列表中每一项要加一个抢购倒计时，没多想，使用 <code>setInterval</code> 快速实现了。</p>
<p>随着列表中项目越来越多，各个项目的倒计时越来越不准，且页面变的越来越卡。</p>
<p>其实很容易想到，n 多个 <code>setInterval</code> 实例同时运行，阻塞了 JS 线程，导致页面越来越卡，计时器计时出现了偏差。有没有办法用一个 <code>setInterval</code> 实例，进行多个倒计时呢?</p>
<p>首先看一下 <code>setInterval</code> 用法:</p>
<pre><code class="language-js">setInterval(() =&gt; {
    // callback
}, 1000)
</code></pre>
<p>如果在 <code>setInterval</code> 中执行多个回调函数，那么就可以实现我们的需求。</p>
<p>简单实现一下:</p>
<pre><code class="language-js">class Timer {
    private timerId
    private cbs = []
    private cbId = 0

    constructor(delay) {
        this.delay = delay
    }

    private start() {
        this.timerId = setInterval(() =&gt; {
            this.cbs.forEach(item =&gt; {
                item.cb()
            })
        }, this.delay)
    }

    private stop() {
        clearInterval(this.timerId)
    }

    add(cb) {
        const id = this.cbId++
        this.cbs.push({ cb, id })
        if(!this.timerId) this.start()
        return id
    }

    remove(cbId) {
        const cbIdx = this.cbs.findIndex(({ id }) =&gt; id === cbId)
        this.cbs.splice(cbIdx, 1)
        if(!this.cbs.length) this.stop()
    }
}
</code></pre>
<p>问题又来了，不同的回调函数，可能需要不同的计时间隔，这怎么处理呢？</p>
<p>可以通过一个计数器，计算 <code>setInterval</code> 的执行次数，执行次数 * 间隔时间就是执行总时间，有了执行总时间就好办了，只需要进行余运算即可。</p>
<p>demo如下:</p>
<pre><code class="language-ts">// some code
let count = 0
let delay = 1000
 setInterval(() =&gt; {
    this.cbs.forEach(({ cb, interval }) =&gt; {
        if(!(count * delay % interval)) {
            cb()
        }
    })
}, delay)
// some code
</code></pre>
<p>上面 demo 中写死了执行间隔为 1000ms，那对于注册了 500ms 执行的回调函数来讲，会延迟 500ms 后才执行。我们可以遍历所有 cbs，从中获取最小的 interval 当做 delay 即可。</p>
<pre><code class="language-ts">// some code
let min = this.cbs[0].interval
let delay = this.cbs.reduce((min, cur) =&gt;  cur.interval &lt; min ? cur.interval : min,min)
// some code
</code></pre>
<p>使用时，只需要 new 一个 Timer 实例，在需要倒计时的地方，通过 add 添加回调函数即可自动启动计时器，删除时，调用 remove 方法，删除完所有注册的回调函数，计时器自动停止。</p>
<pre><code class="language-js">const timer = new Timer()

const timerId = timer.add(() =&gt; {}, 1000)
timer.remove(timerId)
</code></pre>
<p>或者再改造一下，实现类似 <code>setTimeout</code> 和 <code>setInterval</code> 的调用方式</p>
<pre><code class="language-ts">const setTimeoutInterval = timer.add.bind(timer)
const clearTimeoutInterval = timer.remove.bind(timer)
</code></pre>
<p>改造后的倒计时性能无疑好了许多，页面不再卡顿。且无论添加多少个计时回调，它运行的都是同一个计时实例。</p>
<p>使用 <code>setInterval</code> 的计时还是越来越不准，<code>setInterval</code> 会将回调函数间隔插入 JS 线程中，但线程如果正在执行耗时任务，插入的回调函数将偏移其应当在的位置，滞后执行，下一次插入的位置，参照了滞后插入的位置，所以导致运行时间越长，偏差越大。</p>
<p>使用递归 <code>setTimeout</code> ，不断修正将回调函数插入线程的时间，即可获得相对准确的倒计时。</p>
<p>简单实现一下:</p>
<pre><code class="language-js">let count = 0 // 递归次数
let now = Date.now() // 初始执行时间

function countdown() {
    const offset = Date.now() - (now + count * 1000)
    const nextTime = 1000 - offset
    count++

    setTimeout(() =&gt; {
        countdown()
    }, nextTime)
}
countdown()
</code></pre>
<p>这里我们记录了初始执行时间，和 countdown 递归执行的次数，根据这两者，我们可以计算出偏移时间和下次 <code>setTimeout</code> 的时间。</p>
<p>改造后，虽然倒计时准确了许多。但，又回到了上面的问题，列表项越多， <code>setTimeout</code> 实例越多，页面也会越来越卡。</p>
<p>我们可以使用 <code>setTimeout</code> 模拟 <code>setinterval</code>，并将其替换到上面我们的 <code>Timer</code> 类中。即可解决问题。</p>
<pre><code class="language-js">function timeoutInterval(cb, interval = 1000) {
  let count = 0
  let now = Date.now()
  let timerId = null

  function countdown() {
    const offset = Date.now() - (now + count * interval)
    const nextTime = interval - offset
    count++

    cb(timerId)

    timerId = setTimeout(() =&gt; {
      countdown()
    }, nextTime)
  }

  countdown()
}
</code></pre>
<p>这里值得注意的是，由于我们这里使用递归 <code>setTimeout</code>, 所以每次生成的 <code>timeId</code> 都是不一样的，所以设计将其通过 <code>cb</code> 回调函数的参数传出。</p>
<p>用法如下:</p>
<pre><code class="language-js">let i = 0
timeoutInterval((timerId) =&gt; {
    if(i++ &lt; 10) {
        console.log(i)
    } else {
        clearTimeout(timerId)
    }
}, 1000)
</code></pre>
<p>将其替换到 <code>Timer</code> 类中</p>
<pre><code class="language-js">class Timer {
    // some code
    private start() {
        timeoutInterval((timerId) =&gt; {
            this.timerId = timerId
            this.cbs.forEach(item =&gt; {
                item.cb()
            })
        }, 1000)
    }
    // some code
}
</code></pre>
<p>改造后的倒计时性能良好，且因为只有一个计时实例，页面也不会卡顿。</p>
<p>具体实现请查阅代码: <a href="https://github.com/xdoer/TimeoutInterval">TimeoutInterval</a></p>
<p>对于一些秒杀抢购场景，这种倒计时是有问题的，因为本地时间与服务器时间有偏差，如果抢购单纯由前端倒计时来控制，那么很容易出现用户修改本机时间，页面就出现了购买按钮可以直接购买的 bug。由本地计时引起的 bug，在目前市面上的 APP 上很常见，除了抢购场景外，接口防重放机制中会校验客户端请求携带的时间戳，通常约定，如果客户端请求的时间戳与服务端时间偏差在 60s 之外，则该请求无效，所以在修改本机时间后，打开某些 APP，会看到空白页面。</p>
<p>解决办法很简单。</p>
<p>打开应用后，首先将客户端与服务端的偏移时间存到本地，秒杀倒计时的时候，将偏移时间加上即可。这样的话，无论客户端时间是提前还是之后，都对应用没有影响。</p>
<p>简单写个 demo:</p>
<pre><code class="language-js">// 首先获取偏移时间
prequest('/api').then(res =&gt; {
    // nginx 服务器，可以从响应头拿到时间
    const date = res.headers.Date
    const offsetTime = Date.now() - new Date(date).getTime()
    localStorage.setItem('offsetTime', offsetTime)
})

// 封装获取时间方法
function getNow() {
    const offset = localStorage.getItem('offsetTime')
    return Date.now() + Number.parseInt(offset)
}
</code></pre>
<p>回到我们的计时器代码，只需要将其中的 <code>Date.now()</code> 方法替换成 这里的 <code>getNow()</code> 即可。</p>
<p>到目前为止，上面的代码已经可以应对大部分计时场景，但对于秒杀场景来说，本地运行的倒计时可能还是不够可靠，可以设计间歇性请求接口获取服务端时间，更新倒计时，来获得更高计时精确度。</p>
<p>首先大致设计获取服务端时间方法</p>
<pre><code class="language-js">async function getServerTime() {
    const start = Date.now()    // 开启请求时间
    const serverTime = await prequest('/api').then(res =&gt; ...)
    const endTime = Date.now()
    return serverTime + (endTime - startTime) / 2
}
</code></pre>
<p>这里考虑了请求网络消耗的时间。</p>
<p>其次考虑我们倒计时，当每次拿到服务端时间后，加上 <code>interval</code> 时间，判断是否和目标时间相等即可。</p>
<p>demo如下</p>
<pre><code class="language-js">let now = Date.now()
let interval = 1000
setInterval(() =&gt; {
    if (now + interval &gt;=  endTime) {
        // some code
    }
}, interval)

setInterval(() =&gt; {
    getServerTime(res).then(res =&gt; now = res)
}, 5000)
</code></pre>
<p>这里我们维护了两个计时器，一个负责请求接口更新 <code>now</code> 数据，一个进行正常倒计时，写我们的业务逻辑。</p>
<p>当有 n 多个这样的倒计时实例，代码将不可维护。可以改造一下代码，使用类似事件发布订阅的模式来解决这个问题。</p>
<p>首先实现一个 <code>manager</code> 来实现事件发布订阅的逻辑</p>
<pre><code class="language-js">class CountDowmManager {
    queue = []
    tiemrId = null

    constructor({ getRemoteDate, interval }) {
        this.getRemoteDate = getRemoteDate
        this.interval = interval
    }

    private start() {
        this.timerId = timer.add(() =&gt; {
            this.getNow()
        }, this.interval)
    }

    private stop() {
        timer.remove(this.timerId)
    }

    on (countdown) {
        this.queue.push(countdown)
        if(!this.timerId) this.start()
    }

    off(countdown) {
        this.queue.splice(this.queue.findIndex(i =&gt; i === countdown), 1)
        if(!this.queue.length) this.stop()
    }

    private async getNow() {
        try {
            const start = Date.now()
            const nowStr = await this.opt.getRemoteDate()
            const end = Date.now()
            this.queue.forEach((instance) =&gt; (instance.now = new Date(nowStr).getTime() + (end - start) / 2)
        } catch (e) {
            console.log('fix time fail', e)
        }
    }
}
</code></pre>
<p>在 <code>CountDownManager</code> 类中，维护了一个 <code>countdown</code> 实例的队列，每隔 <code>interval</code> 个时间，会请求接口，更新所有实例的 <code>now</code> 值。同时设计将获取服务器时间的函数由参数传入，已满足不同场景的不同需求。</p>
<p>接着，设计倒计时</p>
<pre><code class="language-js">class CountDown {
    now = Date.now()
    timerId = null

   // ... some code
    start() {
        this.timerId = timer.add(() =&gt; {
            this.now += interval

            if (this.now &gt;= endTime) {
                // some code
                return
            }
        })
    }

    // some code
}
</code></pre>
<p>用法如下:</p>
<pre><code class="language-js">const manager = new CountDownManager()

const instance1 = new CountDown()
const instance2 = new CountDown()

manager.on(instance1) 
manager.on(instance2)
</code></pre>
<p>上面的 <code>CounDown</code>  代码中，只考虑了使用 <code>server</code> 更新时间的场景，其实我们也可以将上面使用本地时间进行的倒计时，整合到 <code>countDown</code> 类中。其次，可以设计将 <code>manager</code> 作为参数，传入到 <code>countdown</code> 实例，这样做的好处在于，我们不需要手动的注册和移除 <code>countdown</code> 实例，将 <code>managr</code> 当参数传入，在初始化实例时，就可以自动将当前实例注册；当倒计时结束，自动将当前实例移除。我们还可以根据是否传入 <code>manager</code> 来判断是否需要使用服务端来更新时间。</p>
<p>改造一下代码</p>
<pre><code class="language-js">class CountDown() {

    constructor({ manager, ...opt }) {
        this.manager = manager
        manager ? this.useServerToCountDown(...opt) : this.useLocalToCountDown(...opt)
    }

    useServerToCountDown() {
        // ...some code
        this.manager.on(this)
    }

    // ...some code

    clear() {
        timer.clear(this.timer)
        if(this.manager) {
            this.manager.off(this)
        }
    }
}
</code></pre>
<p>至此，我们就完成了一个高性能，好扩展，易用的计时器了。</p>
<p>完整代码请查阅 <a href="https://github.com/xdoer/CountDown">CountDown</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[想到的一些很好的面试题]]></title>
        <id>https://aiyou.life/post/4XYWTWTx/</id>
        <link href="https://aiyou.life/post/4XYWTWTx/">
        </link>
        <updated>2021-05-30T07:32:50.000Z</updated>
        <summary type="html"><![CDATA[<p>写代码的时候，想到的和遇到的一些问题。想来可以做面试题。特记录于此。</p>
]]></summary>
        <content type="html"><![CDATA[<p>写代码的时候，想到的和遇到的一些问题。想来可以做面试题。特记录于此。</p>
<!-- more -->
<h2 id="对象">对象</h2>
<p>1、<code>{} === {}</code> 是否相等？<br>
2、<code>obj.a === obj.a</code> 是否相等?</p>
<pre><code class="language-ts">const obj = {
    a: {}
}
</code></pre>
<p>3、怎样使 <code>obj.a !== obj.a</code></p>
<pre><code class="language-ts">const obj = {
    get a() {
        return {}
    }
}
</code></pre>
<p>4、<code>obj.a === obj.a</code> 是否相等? <code>obj.a</code> 访问到的是哪一个？</p>
<pre><code class="language-ts">const obj = {
    a: {}
    get a() {
        return {}
    }
}
</code></pre>
<p>5、<code>getter</code> 访问与访问器访问有何区别？<br>
getter 可定义在实例和类上，值为一个无参数的函数，可以惰性赋值。</p>
<p>6、<code>getter</code> 访问与访问器存在相同属性的情况下，如何通过<code>getter</code>访问</p>
<pre><code class="language-ts">const obj = {
    a: {}
    get a() {
        return {}
    }
}
</code></pre>
<p>当在实例上定义 <code>getter</code> 访问，则 <code>getter</code> 存在于实例上。虽然可以定义同名属性，但却访问不到 。</p>
<p>使用 <code>delete obj.a</code> 将会都删掉。</p>
<p>可以考虑将其定义到原型上。</p>
<pre><code class="language-ts">class A {
    a = 1
    get a() {
        return 2
    }
}
const obj = new A()

obj.a === 1 // true
obj.__proto__a === 2 // true

delete obj.a

obj.a === 2 // true
</code></pre>
<p>7、<code>arr[0] === null</code> 是否相等？为什么?</p>
<pre><code class="language-ts">const obj = { a: 1 }
const arr = [obj]
obj = null
</code></pre>
<p>8、<code>arr.get(obj) === null</code> 是否相等？为什么？</p>
<pre><code class="language-ts">let obj = { a: 1 }
const map = new WeakMap()
map.set(obj, { a: 1 })
obj = null
</code></pre>
<p>9、a, b, c 的区别？如何在 class 写法上的原型上定义值？</p>
<pre><code class="language-ts">class A {
    a = 1

    constructor() {
        this.b = 2
    }

    c() {
        return 3
    }
}
</code></pre>
<p>a, b, c 的区别？如何在原型上定义值？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[由封装一个请求库所想到的]]></title>
        <id>https://aiyou.life/post/M4RcI3wfU/</id>
        <link href="https://aiyou.life/post/M4RcI3wfU/">
        </link>
        <updated>2021-05-06T07:32:44.000Z</updated>
        <summary type="html"><![CDATA[<p>是否有一种方式，从底向上的，针对不同的请求内核可以很方便的为其赋予请求库拦截器、中间件、快捷请求等几个通用功能，并且保留不同请求内核的差异化？</p>
]]></summary>
        <content type="html"><![CDATA[<p>是否有一种方式，从底向上的，针对不同的请求内核可以很方便的为其赋予请求库拦截器、中间件、快捷请求等几个通用功能，并且保留不同请求内核的差异化？</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>最近想写一个可以适配多平台的请求库，在研究 xhr 和 fetch 发现二者的参数、响应、回调函数等差别很大。想到如果请求库想要适配多平台，需要统一的传参和响应格式，那么势必会在请求库内部做大量的判断，这样不但费时费力，还会屏蔽掉底层请求内核差异。</p>
<p>阅读 axios 和 umi-request 源码时想到，请求库其实基本都包含了拦截器、中间件和快捷请求等几个通用的，与具体请求过程无关的功能。然后通过传参，让用户接触底层请求内核。问题在于，请求库内置多个底层请求内核，内核支持的参数是不一样的，上层库可能做一些处理，抹平一些参数的差异化，但对于底层内核的特有的功能，要么放弃，要么只能在参数列表中加入一些具体内核的特有的参数。比如在 axios 中，它的请求配置参数列表中，罗列了一些 <a href="https://axios-http.com/docs/req_config">browser only</a>的参数，那对于只需要在 node 环境中运行的 axios 来说，参数多少有些冗余，并且如果 axios 要支持其他请求内核(比如小程序、快应用、华为鸿蒙等)，那么参数冗余也将越来越大，扩展性也差。</p>
<p>换个思路来想，既然实现一个适配多平台的统一的请求库有这些问题，那么是否可以从底向上的，针对不同的请求内核，提供一种方式可以很方便的为其赋予拦截器、中间件、快捷请求等几个通用功能，并且保留不同请求内核的差异化？</p>
<h2 id="设计实现">设计实现</h2>
<p>我们的请求库要想与请求内核无关，那么只能采用内核与请求库相分离的模式。使用时，需要将请求内核传入，初始化一个实例，再进行使用。或者基于请求库，传入内核，预置请求参数来进行二次封装。</p>
<h3 id="基本架构">基本架构</h3>
<p>首先实现一个基本的架构</p>
<pre><code class="language-ts">class PreQuest {
    constructor(private adapter)
    
    request(opt) {
        return this.adapter(opt)
    }
}

const adapter = (opt) =&gt; nativeRequestApi(opt)
// eg: const adapter = (opt) =&gt; fetch(opt).then(res =&gt; res.json())

// 创建实例
const prequest = new PreQuest(adapter)

// 这里实际调用的是 adapter 函数
prequest.request({ url: 'http://localhost:3000/api' })
</code></pre>
<p>可以看到，这里饶了个弯，通过实例方法调用了 adapter 函数。</p>
<p>这样的话，为修改请求和响应提供了想象空间。</p>
<pre><code class="language-ts">class PreQuest {
    // ...some code
    
    async request(opt){
        const options = modifyReqOpt(opt)
        const res = await this.adapter(options)
        return modifyRes(res)
    }

    // ...some code
}
</code></pre>
<h3 id="中间件">中间件</h3>
<p>可以采用 koa 的洋葱模型，对请求进行拦截和修改。</p>
<p>中间件调用示例:</p>
<pre><code class="language-ts">const prequest = new PreQuest(adapter)

prequest.use(async (ctx, next) =&gt; {
    ctx.request.path = '/perfix' + ctx.request.path
    await next()
    ctx.response.body = JSON.parse(ctx.response.body)
})
</code></pre>
<p>实现中间件基本模型？</p>
<pre><code class="language-ts">class Middleware {
    // 中间件列表
    cbs = []
    
    // 注册中间件
    use(cb) {
       this.cbs.push(cb)
       return this
    }
    
    // 执行中间件
    exec(ctx, next){

        let times = -1
    
        const dispatch = (pointer = 0): Promise&lt;any&gt; =&gt; {
            if (cbs.length &lt; pointer) return Promise.resolve()

            const fn = this.cbs[pointer] || next

            if (pointer &lt;= times) throw new Error('next function only can be called once')
             // 确保每个中间价中 next 方法只调用一次
             times = pointer

            // 洋葱模型
             return fn(ctx, () =&gt; dispatch(++pointer))
        }

        return dispatch()
    }
}
</code></pre>
<p>全局中间件，只需要添加一个 use 和 exec 的静态方法即可。</p>
<p>PreQuest 继承自 Middleware 类，即可在实例上注册中间件。</p>
<p>那么怎么在请求前调用中间件?</p>
<pre><code class="language-ts">class PreQuest extends Middleware {
    // ...some code
     
    async request(opt) {
    
        const ctx = {
            request: opt,
            response: {}
        }
        
        // 执行中间件
        async this.exec(ctx, async (ctx) =&gt; {
            ctx.response = await this.adapter(ctx.request)
        })
        
        return ctx.response
    }
        
    // ...some code
}

</code></pre>
<p>中间件模型中，前一个中间件的返回值是传不到下一个中间件中，所以是通过一个对象在中间件中传递和赋值。</p>
<h3 id="拦截器">拦截器</h3>
<p>拦截器是修改参数和响应的另一种方式。</p>
<p>首先看一下 axios 中拦截器是怎么用的。</p>
<pre><code class="language-ts">import axios from 'axios'

const instance = axios.create()

instance.interceptor.request.use(
    (opt) =&gt; modifyOpt(opt),
    (e) =&gt; handleError(e)
)
</code></pre>
<p>根据用法，我们可以实现一个基本结构</p>
<pre><code class="language-ts">class Interceptor {
    cbs = []
    
    // 注册拦截器
    use(successHandler, errorHandler) {
        this.cbs.push({ successHandler, errorHandler })
    }
    
    exec(opt) {
      return this.cbs.reduce(
        (t, c, idx) =&gt; t.then(c.successHandler, this.handles[idx - 1]?.errorHandler),
        Promise.resolve(opt)
      )
      .catch(this.handles[this.handles.length - 1].errorHandler)
    }
}
</code></pre>
<p>代码很简单，有点难度的就是拦截器的执行了。这里主要有两个知识点: Array.reduce 和 Promise.then 第二个参数的使用。</p>
<p>注册拦截器时，<code>successHandler</code> 与 <code>errorHandler</code> 是成对的， successHandler 中抛出的错误，要在对应的 errorHandler 中处理，所以 errorHandler 接收到的错误，是上一个拦截器中抛出的。</p>
<p>拦截器怎么使用呢?</p>
<pre><code class="language-ts">class PreQuest {
    // ... some code
    interceptor = {
        request: new Interceptor()
        response: new Interceptor()
    }
    
    // ...some code
    
    async request(opt){
        
        // 执行拦截器，修改请求参数
        const options = await this.interceptor.request.exec(opt)
        
        const res = await this.adapter(options)
        
        // 执行拦截器，修改响应数据
        const response = await this.interceptor.response.exec(res)
        
        return response
    }
    
}
</code></pre>
<h3 id="拦截器中间件">拦截器中间件</h3>
<p>拦截器也可以是一个中间件，可以通过注册中间件来实现。请求拦截器在 <code>await next()</code> 前执行，响应拦截器在其后。</p>
<pre><code class="language-ts">const instance = new Middleware()

instance.use(async (ctx, next) =&gt; {
    // Promise 链式调用，更改请求参数
    await Promise.resolve().then(reqInterceptor1).then(reqInterceptor2)...
    // 执行下一个中间件、或执行到 this.adapter 函数
    await next()
    // Promise 链式调用，更改响应数据
    await Promise.resolve().then(resInterceptor1).then(resInterceptor2)...
})
</code></pre>
<p>拦截器有请求拦截器和响应拦截器两类。</p>
<pre><code class="language-ts">class InterceptorMiddleware {
    request = new Interceptor()
    response = new Interceptor()
    
    // 注册中间件
    register: async (ctx, next) {
        ctx.request = await this.request.exec(ctx.request)
        await next()
        ctx.response = await thie.response.exec(ctx.response)
    }
}
</code></pre>
<p>使用</p>
<pre><code class="language-ts">const instance = new Middleware()
const interceptor = new InterceptorMiddleware()

// 注册拦截器
interceptor.request.use(
    (opt) =&gt; modifyOpt(opt),
    (e) =&gt; handleError(e)
)

// 注册到中间中
instance.use(interceptor.register)
</code></pre>
<h3 id="类型请求">类型请求</h3>
<p>这里我把类似 <code>instance.get('/api')</code> 这样的请求叫做类型请求。库中集成类型请求的话，难免会对外部传入的adapter 函数的参数进行污染。因为需要为请求方式 <code>get</code> 和路径 <code>/api</code> 分配键名，并且将其混入到参数中，通常在中间件中会有修改路径的需求。</p>
<p>实现很简单，只需要遍历 HTTP 请求类型，并将其挂在 this 下即可</p>
<pre><code class="language-ts">class PreQuest {
    constructor(private adapter) {
        this.mount()
    }
    
    // 挂载所有类型的别名请求
    mount() {
       methods.forEach(method =&gt; {
           this[method] = (path, opt) =&gt; {
             // 混入 path 和 method 参数
             return this.request({ path, method, ...opt })
           }
       })
    }
    
    // ...some code

    request(opt) {
        // ...some code
    }
}

</code></pre>
<h3 id="简单请求">简单请求</h3>
<p>axios 中，可以直接使用下面这种形式进行调用</p>
<pre><code class="language-ts">axios('http://localhost:3000/api').then(res =&gt; console.log(res))
</code></pre>
<p>我将这种请求方式称之为简单请求。</p>
<p>我们这里怎么实现这种写法的请求方式呢？</p>
<p>不使用 class ，使用传统函数类写法的话比较好实现，只需要判断函数是否是 new 调用，然后在函数内部执行不同的逻辑即可。</p>
<p>demo 如下</p>
<pre><code class="language-ts">function PreQuest() {
    if(!(this instanceof PreQuest)) {
        console.log('不是new 调用')
        return // ...some code
    }
   
   console.log('new调用') 
   
   //... some code
}

// new 调用
const instance = new PreQuest(adapter)
instance.get('/api').then(res =&gt; console.log(res))

// 简单调用
PreQuest('/api').then(res =&gt; console.log(res))
</code></pre>
<p>class 写法的话，不能进行函数调用。我们可以在 class 实例上做文章。</p>
<p>首先初始化一个实例，看一下用法</p>
<pre><code class="language-ts">const prequest = new PreQuest(adapter)

prequest.get('http://localhost:3000/api')

prequest('http://localhost:3000/api')
</code></pre>
<p>通过 new 实例化出来的是一个对象，对象是不能够当做函数来执行，所以不能用 new 的形式来创建对象。</p>
<p>再看一下 axios 中生成实例的方法 <code>axios.create</code>, 可以从中得到灵感，如果 <code>.create</code> 方法返回的是一个函数，函数上挂上了所有 new 出来对象上的方法，这样的话，就可以实现我们的需求。</p>
<p>简单设计一下:</p>
<p>方式一: 拷贝原型上的方法</p>
<pre><code class="language-ts">class PreQuest {

    static create(adapter) {
        const instance = new PreQuest(adapter)
        
        function inner(opt) {
           return instance.request(opt)
        }
        
        for(let key in instance) {
            inner[key] = instance[key]
        }
        
        return inner
    }
}
</code></pre>
<p><strong>注意: 在某些版本的 es 中，<code>for in</code> 循环遍历不出 class 生成实例原型上的方法。</strong></p>
<p>方式二: 还可以使用 Proxy 代理一个空函数，来劫持访问。</p>
<pre><code class="language-ts">class PreQuest {
    
    // ...some code

    static create(adapter) {
        const instance = new PreQuest(adapter)
       
        return new Proxy(function (){}, {
          get(_, name) {
            return Reflect.get(instance, name)
          },
          apply(_, __, args) {
            return Reflect.apply(instance.request, instance, args)
          },
        })
    }
}
</code></pre>
<p>上面两种方法的缺点在于，通过 <code>create</code> 方法返回的将不再是 <code>PreQuest</code> 的实例，即</p>
<pre><code class="language-ts">const prequest = PreQuest.create(adapter)

prequest instanceof PreQuest  // false
</code></pre>
<p>个人目前还没有想到，判断 <code>prequest</code> 是不是 <code>PreQuest</code> 实例有什么用，并且也没有想到好的解决办法。有解决方案的请在评论里告诉我。</p>
<p>使用 <code>.create</code> 创建 '实例' 的方式可能不符合直觉，我们还可以通过 Proxy 劫持 new 操作。</p>
<p>Demo如下:</p>
<pre><code class="language-ts">class InnerPreQuest {
  create() {
     // ...some code
  }
}

const PreQuest = new Proxy(InnerPreQuest, {
    construct(_, args) {
        return () =&gt; InnerPreQuest.create(...args)
    }
})
</code></pre>
<h3 id="请求锁">请求锁</h3>
<p>如何实现在请求接口前，先拿到 token 再去请求？</p>
<p>下面的例子中，页面同时发起多个请求</p>
<pre><code class="language-ts">const prequest = PreQuest.create(adapter)

prequest('/api/1').catch(e =&gt; e)     // auth fail
prequest('/api/2').catch(e =&gt; e)    // auth fail
prequest('/api/3').catch(e =&gt; e)    // auth fail
</code></pre>
<p>首先很容易想到，我们可以使用中间件为其添加 token</p>
<pre><code class="language-ts">prequest.use(async (ctx, next) =&gt; {
    ctx.request.headers['Authorization'] = `bearer ${token}`
    await next()
})
</code></pre>
<p>但 token 值从何而来？token 需要请求接口得来，并且需要重新创建请求实例，以避免重新走添加 token 的中间件的逻辑。</p>
<p>简单实现一下</p>
<pre><code class="language-ts">const tokenRequest = PreQuest.create(adapter)

let token = null
prequest.use(async (ctx, next) =&gt; {
    if(!token) {
        token = await tokenRequest('/token')
    }
    ctx.request.headers['Authorization'] = `bearer ${token}`
    await next()
})
</code></pre>
<p>这里使用了 token 变量，来避免每次请求接口，都去调接口拿 token。</p>
<p>代码乍一看没有问题，但仔细一想，当同时请求多个接口，tokenRequest 请求还没有得到响应时，后面的请求又都走到这个中间件，此时 token 值为空，会造成多次调用 tokenRequest。那么如何解决这个问题？</p>
<p>很容易想到，可以加个锁机制来实现</p>
<pre><code class="language-ts">let token = null
let pending = false
prequest.use(async (ctx, next) =&gt; {
    if(!token) {
        if(pending) return
        pending = true
        token = await tokenRequest('/token')
        pending = flase
    }
    ctx.request.headers['Authorization'] = `bearer ${token}`
    await next()
})
</code></pre>
<p>这里我们加了 pending 来判断 tokenRequest 的执行，成功解决了 tokenRequest 执行多次的问题，但又引入了新的问题，在执行 tokenRequest 时，后面到来的请求应当怎么处理？上面的代码，直接 return 掉了，请求将被丢弃。实际上，我们希望，请求可以在这里暂停，当拿到 token 时，再请求后面的中间件。</p>
<p>暂停，我们也可以很容想到使用 async、await 或者 promise 来实现。但在这里如何用呢？</p>
<p>我从 axios 的 <a href="https://github.com/axios/axios/blob/e9965bfafc82d8b42765705061b9ebe2d5532493/lib/cancel/CancelToken.js#L17">cancelToken</a> 实现中得到了灵感。axios 中，利用 promise 简单实现了一个状态机，将 Promise 中的 resolve 赋值到外部局部变量，实现对 promise 流程的控制。</p>
<p>简单实现一下</p>
<pre><code class="language-ts">let token = null
let pending = false
let resolvePromise
let promise = new Promise((resolve) =&gt; resolvePromise = resolve)

prequest.use(async (ctx, next) =&gt; {
    if(!token) {
        if(pending) {
            // promise 控制流程
            token = await promise
        } else {
            pending = true
            token = await tokenRequest('/token')
            // 调用 resolve，使得 promise 可以执行剩余的流程
            resolvePromise(token)
            pending = flase
        }
    } 

    ctx.request.headers['Authorization'] = `bearer ${token}`
    await next()
})
</code></pre>
<p>当执行 tokenRequest 时，其余请求的接口，都会进入到一个 promise 控制的流程中，当 token 得到后，通过外部 resolve, 控制 promise 继续执行，以此设置请求头，和执行剩余中间件。</p>
<p>这种方式虽然实现了需求，但代码丑陋不美观。</p>
<p>我们可以将状态都封装到一个函数中。以实现类似下面这种调用。这样的调用符合直觉且美观。</p>
<pre><code class="language-ts">prequest.use(async (ctx, next) =&gt; {
  const token = await wrapper(tokenRequest)
  ctx.request.headers['Authorization'] = `bearer ${token}`
  await next()
})
</code></pre>
<p>怎么实现这样一个 wrapper 函数？</p>
<p>首先，状态不能封装到 wrapper 函数中，否则每次都会生成新的状态，wrapper 将形同虚设。可以使用闭包函数将状态保存。</p>
<pre><code class="language-ts">function createWrapper() {
    let token = null
    let pending = false
    let resolvePromise
    let promise = new Promise((resolve) =&gt; resolvePromise = resolve)
    return function (fn) {
        if(pending) return promise
        if(token) return token

        pending = true

        token = await fn()

        pending = false
        resolvePromise(token)

        return token
    }
}
</code></pre>
<p>使用时，只需要利用 <code>createWrapper</code> 生成一个 <code>wrapper</code> 即可</p>
<pre><code class="language-ts">const wrapper = createWrapper()

prequest.use(async (ctx, next) =&gt; {
  const token = await wrapper(tokenRequest)
  ctx.request.headers['Authorization'] = `bearer ${token}`
  await next()
})
</code></pre>
<p>这样的话，就可以实现我们的目的。</p>
<p>但，这里的代码还有问题，状态封装在 createWrapper 内部，当 token 失效后，我们将无从处理。</p>
<p>比较好的做法是，将状态从 <code>createWrapper</code> 参数中传入。</p>
<p>代码实现，请参考<a href="https://github.com/xdoer/PreQuest/blob/104c178e7c3a1b8edd8c6d36ad603e880297eba2/packages/lock/src/index.ts#L5">这里</a></p>
<h2 id="实战">实战</h2>
<p>以微信小程序为例。小程序中自带的 <code>wx.request</code> 并不好用。使用上面我们封装的代码，可以很容易的打造出一个小程序请求库。</p>
<h3 id="封装小程序原生请求">封装小程序原生请求</h3>
<p>将原生小程序请求 Promise 化，设计传参 opt 对象</p>
<pre><code class="language-ts">function adapter(opt) {
  const { path, method, baseURL, ...options } = opt
  const url = baseURL + path
  return new Promise((resolve, reject) =&gt; {
    wx.request({
      ...options,
      url,
      method,
      success: resolve,
      fail: reject,
    })
  })
}

</code></pre>
<h3 id="调用">调用</h3>
<pre><code class="language-ts">const instance = PreQuest.create(adapter)

// 中间件模式
instance.use(async (ctx, next) =&gt; {
    // 修改请求参数
    ctx.request.path = '/prefix' + ctx.request.path
    
    await next()
    
    // 修改响应
    ctx.response.body = JSON.parse(ctx.response.body)
})

// 拦截器模式
instance.interecptor.request.use(
    (opt) =&gt; {
        opt.path = '/prefix' + opt.path
        return opt
    }
)

instance.request({ path: '/api', baseURL: 'http://localhost:3000' })

instance.get('http://localhost:3000/api')

instance.post('/api', { baseURL: 'http://loclahost:3000' })
</code></pre>
<h3 id="获取原生请求实例">获取原生请求实例</h3>
<p>首先看一下在小程序中怎样中断请求</p>
<pre><code class="language-ts">const request = wx.request({
    // ...some code
})

request.abort()
</code></pre>
<p>使用我们封装的这一层，将拿不到原生请求实例。</p>
<p>那么怎么办呢？我们可以从传参中入手</p>
<pre><code class="language-ts">function adapter(opt) {
    const { getNativeRequestInstance } = opt
    
    let resolvePromise: any
    getNativeRequestInstance(new Promise(resolve =&gt; (resolvePromise = resolve)))
    
    return new Promise(() =&gt; {
        const nativeInstance = wx.request(
           // some code
        )
        
        resolvePromise(nativeInstance)
    })
}
</code></pre>
<p>用法如下:</p>
<pre><code class="language-ts">const instance = PreQuest.create(adapter)

instance.post('http://localhost:3000/api', {
    getNativeRequestInstance(promise) {
      promise.then(instance =&gt; {
          instance.abort()
      })
    }
})
</code></pre>
<p>需要注意的是：因为 <code>wx.request</code> 的执行是在 n 个中间件、拦截器之后执行的，里面存在大量异步任务，所以通过上面拿到的 <code>instance</code> 只能在异步中执行。</p>
<h3 id="兼容多平台小程序">兼容多平台小程序</h3>
<p>查看了几个小程序平台和快应用，发现请求方式都是小程序的那一套，那其实我们完全可以将 <code>wx.request</code> 拿出来，创建实例的时候再传进去。</p>
<h2 id="结语">结语</h2>
<p>上面的内容中，我们基本实现了一个与请求内核无关的请求库，并且设计了两种拦截请求和响应的方式，我们可以根据自己的需求和喜好自由选择。</p>
<p>这种内核装卸的方式非常容易扩展。当面对一个 axios 不支持的平台时，也不用费劲的去找开源好用的请求库了。我相信很多人在开发小程序的时候，基本都有去找 axios-miniprogram 的解决方案。通过我们的 PreQuest 项目，可以体验到类似 axios 的能力。</p>
<p><a href="https://github.com/xdoer/PreQuest">PreQuest</a> 项目中，除了上面提到的内容，还提供了全局配置、全局中间件、别名请求等功能。项目中也有基于 <code>PreQuest</code> 封装的请求库，<a href="https://github.com/xdoer/PreQuest/tree/main/packages/miniprogram">@prequest/miniprogram</a>,<a href="https://github.com/xdoer/PreQuest/tree/main/packages/fetch">@prequest/fetch</a>...也针对一些使用原生 xhr、fetch 等 API 的项目，提供了一种不侵入的方式来赋予 PreQuest的能力 <a href="https://github.com/xdoer/PreQuest/tree/main/packages/wrapper">@prequest/wrapper</a></p>
<h2 id="参考">参考</h2>
<p><a href="https://github.com/axios/axios">axios</a>: https://github.com/axios/axios</p>
<p><a href="https://github.com/umijs/umi-request">umi-request</a>:https://github.com/umijs/umi-request</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Fower: 一个多平台原子类 CSS In JS 样式库]]></title>
        <id>https://aiyou.life/post/ZSut5c_dE/</id>
        <link href="https://aiyou.life/post/ZSut5c_dE/">
        </link>
        <updated>2021-04-28T12:41:50.000Z</updated>
        <summary type="html"><![CDATA[<p>在过去的一年半中，我们团队分别使用了 Taro  React 开发小程序， React 开发 Web 程序 和使用  React Native 开发 App。使用的样式构建也各种各样，并不统一，在小程序中，使用 SCSS，在 Web 中使用 tailwind, 在  React Native 中使用 StyleSheet.create 创建样式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在过去的一年半中，我们团队分别使用了 Taro  React 开发小程序， React 开发 Web 程序 和使用  React Native 开发 App。使用的样式构建也各种各样，并不统一，在小程序中，使用 SCSS，在 Web 中使用 tailwind, 在  React Native 中使用 StyleSheet.create 创建样式。</p>
<!-- more -->
<p>在这三种写法中来回切换是痛苦的。</p>
<h2 id="简介">简介</h2>
<p>我们从 tailwind 中获得了灵感， 将 tailwind 的原子样式 与  JSX Prop 结合，开发了 Fower。Fower 在  JSX 组件外包装了一层，通过收集整合原子样式属性，生成 className 或者 style 属性，并将其注入到内层组件中。由于 Fower 组件本质是一个  JSX 组件，因而也获得了 VSCode 的智能提示，书写样式时，只需要打个首字母，就可以联想出所有的原子样式，回车即可填充属性，这种开发体验是相当爽的。</p>
<figure data-type="image" tabindex="1"><img src="https://aiyou.life/post-images/1619614139846.png" alt="" loading="lazy"></figure>
<p>在此基础上，Fower 通过附加各种属性后缀，支持了伪类，媒体查询，主题切换，暗黑模式等功能；提供了一些布局属性，可以快速让多子元素垂直、水平居中；也有一些功能属性，可以快速裁剪文字，省略显示；可以通过一个属性，构建出一个方形或者圆；还有功能强劲的 css 属性，让你使用各种子元素选择器。。。除了内置的这些属性，Fower 也提供了相关 API，可以让你可以定制化你自己的属性实现。</p>
<p>我们除了对  React, Taro  React,  React Native 封装了组件包外，还针对 Vue, Svelte 等框架进行了部分兼容和适配，Fower 提供了 VSCode 插件，解决了在  React Like 之外的框架的智能提示。</p>
<p>使用 Fower，基本上<strong>可以让你不用再写烦人的 CSS 文件</strong></p>
<h2 id="对比">对比</h2>
<p>相比于 Tailwind, Fower 的优势是明显的。</p>
<blockquote>
<ul>
<li>VSCode 插件。Tailwind 的使用离不开 VSCode 插件。Fower 在  React Like 框架中，利用 VSCode 智能提示就可以联想出各种属性，在其他框架中，才需要安装 VSCode 插件</li>
<li>开箱即用。Fower 只需要安装对应的框架包，即可直接使用，无需进行繁杂的配置。</li>
<li>体积。对于类似 <code>p1</code>, <code>p2</code> 到 <code>p100</code> 这种属性，Tailwind 中枚举了每一个属性的样式，导致体积异常的庞大。Fower 在  React Like 中属于运行时库，对属性具有编程性，可以动态生成样式，所以体积非常小。在非  React Like 框架中，Fower 通过收集模板的原子属性样式也是动态生成样式。</li>
<li>多端使用。Fower 针对市面上主流的框架进行了针对性适配，你可以在  React, Preact, Vue, Svelte,  React Native, Taro  React 小程序, Remax 小程序等平台使用 Fower。Tailwind 不支持在  React Native 使用，并且在 Taro, Remax 等小程序环境中没有支持。</li>
</ul>
</blockquote>
<p>由于 Fower 是运行时 UI 库，所以相对于 Tailwind 有一定的运行时损耗。但对于设备算力越来越强大的今天，这点损耗可以忽略不计。但 Fower 还是尽可能的使用了各种手段提高运行效率，Fower 内部对所有遍历过的属性进行缓存，极大提高运行速度。</p>
<h2 id="项目">项目</h2>
<p><a href="https://fower.vercel.app/">官方文档（https://fower.vercel.app/）</a></p>
<p><a href="https://github.com/forsigner/fower">项目地址（https://github.com/forsigner/fower）</a></p>
<h2 id="功能一览">功能一览</h2>
<p>下面演示了使用 Fower/react 框架包的 Box 组件编写的 demo。实际上，直接使用 Box 标签也是可以用的，但需要额外的配置。</p>
<h3 id="基本使用"><a href="https://fower.vercel.app/zh-cn/docs/basic">基本使用</a></h3>
<p>Fower 提供了大量的原子样式属性，可以极速构建 UI。</p>
<pre><code class="language-html">&lt;Box text2XL fontBold green500 className=&quot;user&quot; style={{ fontWeight: 'bold' }}&gt;
  Hi, Fower
&lt;/Box&gt;
</code></pre>
<h3 id="可编程动态样式">可编程/动态样式</h3>
<p>你可以通过为属性赋值的方式，来编写动态样式</p>
<pre><code class="language-html">&lt;Box
  text-14
  display=&quot;block&quot;
  color=&quot;red&quot;
  blue={false}
  p-10
  m-10rem
  bg=&quot;red&quot;
  bgRed={true}
  bgBlue={false}
&gt;
  Hi, Fower
&lt;/Box&gt;
</code></pre>
<h3 id="css-属性"><a href="https://fower.vercel.app/zh-cn/docs/css-prop">CSS 属性</a></h3>
<p>Fower 中提供了强大的 CSS 属性，实现了大部分 CSS 的功能。</p>
<pre><code class="language-html">&lt;Box
  text4XL
  css={{
    backgroundColor: '#edf2f7',
    ':hover': {
      backgroundColor: '#feebc8',
    },
    '.title': {
      fontWeight: 'bold',
    },
    span: {
      color: 'deeppink',
    },
  }}
&gt;
  &lt;Box className=&quot;title&quot;&gt;Nested demo&lt;/Box&gt;
  &lt;span&gt;Hi, Fower!&lt;/span&gt;
&lt;/Box&gt;
</code></pre>
<h3 id="伪类响应式"><a href="https://fower.vercel.app/zh-cn/docs/pseudo">伪类/响应式</a></h3>
<p>Fower 通过后缀的方式，支持了伪类，响应式等功能</p>
<pre><code class="language-html">&lt;Box text2XL text3XL--hover red--first-child fontBold green500&gt;
  &lt;Box&gt;Hi, Fower&lt;/Box&gt;
&lt;/Box&gt;
&lt;Box textSM textLG--sm text4XL--md text6XL--lg&gt;
  Lorem ipsum dolor sit amet
&lt;/Box&gt;
</code></pre>
<h3 id="颜色助手"><a href="https://fower.vercel.app/zh-cn/docs/color-helper">颜色助手</a></h3>
<p>颜色助手可以快速增加或减少颜色的亮度，透明度等等</p>
<pre><code class="language-html">&lt;Box toEvenly toCenterY&gt;
  &lt;Box red300&gt;normal&lt;/Box&gt;
  &lt;Box red300--D40&gt;darken&lt;/Box&gt;
&lt;/Box&gt;
</code></pre>
<h3 id="主题"><a href="https://fower.vercel.app/zh-cn/docs/theme">主题</a></h3>
<p>Fower 内置了主题。你可以通过 setTheme API 更改和添加配置。</p>
<pre><code class="language-html">import { setTheme } from '@fower/core'

setTheme({
  spacings: {
    10086: 110,
  },
  color: {
    gray10086: '#FFFFFF'
  }
})

&lt;Box textSM bgGray10086 bgGray10086--dark p10086&gt;
  Lorem ipsum dolor sit amet
&lt;/Box&gt;
</code></pre>
<h3 id="与第三方组件库一起使用">与第三方组件库一起使用</h3>
<p>上文中提到 Fower 原理是通过给现有组件包装了一层，通过收集整合原子样式属性，最终将 className 或 style 属性注入到内层组件。因而与第三方组件使用时，只需要利用 styled API 包装即可。</p>
<pre><code class="language-html">import { Button as AntdButton } from 'antd'
import { styled } from '@fower/styled'

const Button = styled(AntdButton)

&lt;Button red300 red400={false} text={7 + 7}&gt;
  normal
&lt;/Button&gt;
</code></pre>
<h3 id="属性冲突">属性冲突</h3>
<p>Fower 组件提供的属性与三方属性冲突时，Fower 也提供了解决方案。</p>
<pre><code class="language-html">import { Button as AntdButton } from 'antd'
import { styled } from '@fower/styled'

const Button = styled(AntdButton)

&lt;Button excludedProps={['block']} block&gt;
  normal
&lt;/Button&gt;
</code></pre>
<h3 id="类名">类名</h3>
<p>Fower 同样支持了 tailwind 的用法</p>
<pre><code class="language-html">&lt;Box className=&quot;toCenter square-400 bgRed400&quot;&gt;
  &lt;Box className=&quot;white&quot;&gt;Lorem ipsum&lt;/Box&gt;
&lt;/Box&gt;
</code></pre>
<h3 id="动画">动画</h3>
<p>Fower 提供了 keyframes API，可以快速创建动画。</p>
<pre><code class="language-html">import { Box } from '@fower/react';
import { keyframes } from '@fower/core';

const bounce = keyframes({
  'from, 20%, 53%, 80%, to': {
    transform: 'translate3d(0,0,0)',
    padding: 10,
  },
    '40%, 43%': {
    transform: 'translate3d(0, -30px, 0)',
  },
})

&lt;Box
  text-30
  css={{
    animation: `${bounce} 1s ease infinite`,
  }}
&gt;
  40 Lorem ipsum dolor sit amet
&lt;/Box&gt;
</code></pre>
<h3 id="扩展">扩展</h3>
<p>Fower 提供了 <a href="https://fower.vercel.app/zh-cn/docs/add-atom">addAtom</a> API 可以快速扩展原子样式属性。但这只能在自己的项目中使用。</p>
<p>Fower 提供了灵活的插件机制，你可以编写自己的样式 Util，供他人使用。</p>
<pre><code class="language-html">import { setConfig } from '@fower/core';
import ellipsis from 'fower-plugin-ellipsis';

setConfig({
  plugin: [ellipsis],
});
</code></pre>
<h2 id="结语">结语</h2>
<p>经过团队半年的不懈努力，Fower 日渐完善，我们也在项目中积极使用。目前在我们小程序项目中做到了仅有一个 app.scss 样式文件的地步。我们封装了很多框架包，也在积极测试与使用，但难免会遇到很多 Bug，希望大家积极试用使用 Fower，也希望 Fower 项目能够真正的帮助你解决样式开发的痛点。谢谢大家。</p>
<figure data-type="image" tabindex="2"><img src="https://aiyou.life/post-images/1619618374404.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Taro小程序开发提升效率的几点分享-路由篇]]></title>
        <id>https://aiyou.life/post/FkN_iGcYQ/</id>
        <link href="https://aiyou.life/post/FkN_iGcYQ/">
        </link>
        <updated>2020-09-22T13:00:12.000Z</updated>
        <summary type="html"><![CDATA[<p>我们都知道，小程序开发一个页面，首先要在 pages 文件夹在新建文件夹，然后在 appConfig 中配置页面完整的路径地址，在进行路由跳转时，还需要在 navigateTo 中写下完整的页面路径。当页面数量少，代码量小时，似乎可以接受，但当代码量大，项目存在好几个分包时，页面跳转路径会变得非常长，书写页面路径会变得越来越困难，代码也不够美观和直观。解析路由参数时，还需要经过几步转换才能得到。。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我们都知道，小程序开发一个页面，首先要在 pages 文件夹在新建文件夹，然后在 appConfig 中配置页面完整的路径地址，在进行路由跳转时，还需要在 navigateTo 中写下完整的页面路径。当页面数量少，代码量小时，似乎可以接受，但当代码量大，项目存在好几个分包时，页面跳转路径会变得非常长，书写页面路径会变得越来越困难，代码也不够美观和直观。解析路由参数时，还需要经过几步转换才能得到。。</p>
<!-- more -->
<h2 id="环境">环境</h2>
<p>基础环境: taro 3.0.5 / react 16.10.0 / typescript 4.1.0</p>
<p>技术栈: React Hooks</p>
<h2 id="路由部分">路由部分</h2>
<p>Taro 小程序路由方法调用示例</p>
<p>路由跳转</p>
<pre><code class="language-typescript">navigateTo({
  url: `/package-appointment/pages/manage-appointments/index?roomId=${roomId}&amp;appointmentId=${appointmentId}&amp;scriptId=${scriptId}`
})
</code></pre>
<p>参数解析</p>
<pre><code class="language-typescript">const { params } = useRouter()
const { roomId, appointmentId, scriptId } = params
const oRoomId = Number.parseInt(roomId)
const oAppointmentId = Number.parseInt(appointmentId)
const oScriptId = Number.parseInt(scriptId)
</code></pre>
<h2 id="优化方案">优化方案</h2>
<h3 id="part-1-路由表文件">PART 1 路由表文件</h3>
<p>新建一个路由表文件 routeTable.ts，为路径命名。</p>
<pre><code class="language-typescript">export enum URLs {
  INDEX = '/pages/index/index',
  MANAGE_APPOINTMENTS = '/package-appointment/pages/manage-appointments/index',
  INTENT_DETAIL = '/package-intent/pages/intent-detail/index'
}
</code></pre>
<p>调用时，只需要引入路由表文件</p>
<pre><code class="language-typescript">import { URLs } from '@/common/routeTable'
...
navigateTo({
  url: `${URLs.MANAGE_APPOINTMENTS}?roomId=${roomId}&amp;appointmentId=${appointmentId}&amp;scriptId=${scriptId}`
})
...
</code></pre>
<p>引入了路由表文件的同时，引入了新的问题，新建一个页面要维护两个路由地址文件，一个是 app.config ，另一个就是路由表文件 routeTable。增加了维护成本，同时两个文件，只要有一点错误，页面就不能正确的被访问。怎么处理这个问题？</p>
<h3 id="part-2-脚本更新路由表与相关配置">PART 2 脚本更新路由表与相关配置</h3>
<p>无论 app.config 路径配置还是路由表配置，页面与路径是对应关系，我们可以写一个脚本去处理问题。首先扫描源码文件夹，通过正则表达式找到 pages 和 package- 下的所有页面。找到文件后，获取文件夹名称作为路由表的 shortName, 构造数据后即可替换和新建到 app.config 和 routeTable 中。</p>
<p>除此之外，还可以顺带把 project.config.json 中 miniprogram 字段更新，用于开发页面进行快捷调试。</p>
<p>脚本完成之后，每次开发页面时，只需要在 pages 目录下或者分包 pages 目录下新建目录，运行脚本命令即可自动更新 app.config 、 project.config 和 routeTable。</p>
<p>注意:</p>
<blockquote>
<ul>
<li>查找页面文件，默认 pages 下的一级目录为所有页面文件，这里需要开发者拥有良好的开发习惯，写的页面没有进行嵌套。</li>
<li>脚本代码很简单，就不新建仓库了，完整代码已经贴到了最下面</li>
</ul>
</blockquote>
<h3 id="part-3-地址参数改造">PART 3 地址参数改造</h3>
<p>观察 PART 1 部分的代码，其实可以看到，虽然通过路由表形式缩短了一部分地址的长度，但是参数部分还可以做些文章。</p>
<pre><code class="language-typescript">// queryParams 封装
const covertObjToSearchParams = (searchObj: commonObjectProps = {}) =&gt; {
  let searchParams = ''
  for (let i in searchObj) {
    searchParams = searchParams + `${i}=${searchObj[i]}&amp;`
  }
  return searchParams.slice(0, -1)
}

const queryParams = covertObjToSearchParams({ roomId, appointmentId, scriptId })

navigateTo({
  url: `${URLs.MANAGE_APPOINTMENTS}?${queryParams}`
})

</code></pre>
<p>通过这种方式传递参数，简洁直观，方便不少。</p>
<h3 id="part-4-路由跳转方法改造">PART 4 路由跳转方法改造</h3>
<p>小程序中的方法大都都是通过一个对象传递的参数，这是因为大多数方法都有很多参数，通过对象传参则显得代码整洁友好。观察我们的代码，用到的最多的就是一个 url 参数, 那我们完全可以直接将地址放到第一个参数位上。</p>
<p>navigateTo 方法改造</p>
<pre><code class="language-typescript">import { navigateTo as originNavigateTo } from '@tarojs/taro'

export function navigateTo(url: string, params?: commonObjectProps, opt?: commonObjectProps) {
  if (!params) return originNavigateTo({ url, ...opt })

  const _url = `${url}?${covertObjToSearchParams(params)}`
  originNavigateTo({ url: _url, ...opt })
}
</code></pre>
<p>navigateTo 调用</p>
<pre><code class="language-typescript">navigateTo(URLs.MANAGE_APPOINTMENTS, { roomId, appointmentId, scriptId })`
</code></pre>
<p>相比前文中的最开始时的路由调用，这里更加简洁明了</p>
<h3 id="part-5-路由参数解析方法改造">PART 5 路由参数解析方法改造</h3>
<p>Taro 中提供了 <strong>useRouter</strong> hooks去解析路由参数，但该 Hooks 解析出的参数都是字符串类型。</p>
<p>当使用参数时，需要先导出 <strong>params</strong> 对象，然后再拿到参数值，对于一些数字、布尔类型值还只能再通过转换获得原始值。流程繁琐且复杂。怎么解决这个问题?</p>
<p>首先对 useRouter 进行初步封装</p>
<pre><code class="language-typescript">import { useRouter as useOriginRouter } from '@tarojs/taro'

export function useRouter&lt;T&gt;(): T {
  const { params } = useOriginRouter()
  return params
}
</code></pre>
<p>封装完的 useRouter 只简化了导出 params 的过程，而参数类型转换还是只能根据具体的参数进行具体转换。那这样的封装其实还是有点鸡肋。</p>
<p>通过 queryParams 传递的参数只能是字符串形式的，所以解析参数也只能解析出字符串。因而可以通过 <strong>JSON.stringify</strong> 将参数对象转换为字符串，解析时再利用 <strong>JSON.parse</strong> 解析出保有原始数据类型的参数。</p>
<pre><code class="language-typescript">import { useRouter as useOriginRouter, navigateTo as originNavigateTo } from '@tarojs/taro'

// 路由跳转
export function navigateTo(url: string, params?: object) {
  if (!params) return originNavigateTo({ url })

  const _url = `${url}?navParams=${JSON.stringify(params)}`
  originNavigateTo({ url: _url })
}

// 路由解析
export function useRouter&lt;T&gt;(): T {
  const { params } = useOriginRouter()

  try {
    const targetParams = params['navParams']
    if (targetParams) return JSON.parse(targetParams)
  } catch (e) {
    console.warn('参数解析失败', e)
  }

  return {} as T
}
</code></pre>
<p>使用这种封装方式，虽然 URL 不直观且不利于 SEO，但在小程序环境中，用户根本不会看到 URL，且在当前小程序环境中，SEO似乎根本没什么用。</p>
<p>使用我们封装好的代码，文章开头给出的示例可简化为如下代码:</p>
<pre><code class="language-typescript">import { navigateTo, useRouter } from '@/app'

navigateTo(URLs.MANAGE_APPOINTMENTS, { roomId, appointmentId, scriptId })
...

const { roomId, appointmentId, scriptId } = useRouter()
...

</code></pre>
<h2 id="完整路由脚本生成和代码">完整路由脚本生成和代码</h2>
<p>脚本代码很简单，就不新建仓库存了。</p>
<h3 id="主脚本文件">主脚本文件</h3>
<pre><code class="language-javascript">const path = require('path')
const fs = require('fs')
const { isDir, readDir, readFile, writeFile } = require('./util')
const PROJECT_CONFIG = require('../project.config.json')

const BASE_PATH = path.resolve(__dirname, '..')
const APP_CONFIG_PATH = path.resolve(BASE_PATH, 'src/app.config.ts')
const URL_TABLE_PATH = path.resolve(BASE_PATH, 'src/common/url.constant.ts')
const PACKAGE_CONFIG_PATH = path.resolve(BASE_PATH, 'project.config.json')

function handleMainPageConfig(dirsName, fileStr) {
  const paths = dirsName.map((dir) =&gt; `'pages/${dir}/index'\n`)
  fileStr = fileStr.replace(/pages[\S\s]*subPackages/, `pages: [${paths}], subPackages`)
  return fileStr
}

function handleSubPageConfig(rootPath, dirsName, subPackage) {
  const [, name] = rootPath.split('-')
  subPackage.push({
    root: rootPath,
    name,
    pages: dirsName.map((name) =&gt; `pages/${name}/index`),
  })
  return subPackage
}

function handleMainRouteTable(dirsName, fileStr) {
  const paths = dirsName.map((dir) =&gt; `'/pages/${dir}/index'\n`)
  for (let i = 0; i &lt; dirsName.length; i++) {
    const current = dirsName[i]
    const name = current
      .split('-')
      .map((v) =&gt; v.toUpperCase())
      .join('_')
    fileStr = fileStr + `${name}=${paths[i]},`
  }
  return fileStr
}

function handleSubRouteTable(rootPath, dirsName, fileStr) {
  const paths = dirsName.map((dir) =&gt; `'/${rootPath}/pages/${dir}/index'\n`)
  for (let i = 0; i &lt; dirsName.length; i++) {
    const current = dirsName[i]
    const name = current
      .split('-')
      .map((v) =&gt; v.toUpperCase())
      .join('_')
    fileStr = fileStr + `${name}=${paths[i]},`
  }
  return fileStr
}

function handleMainProjectConfig(dirsName, routes) {
  const paths = dirsName.map((dir) =&gt; `pages/${dir}/index`)
  return routes.concat(paths.map((_path, idx) =&gt; {
    return {
      id: idx + 1,
      name: dirsName[idx],
      pathName: _path,
      query: '',
    }
  }))
}

function handleSubProjectConfig(rootPath, dirsName, routes) {
  const paths = dirsName.map((dir) =&gt; `${rootPath}/pages/${dir}/index`)
  return routes.concat(
    paths.map((_path, idx) =&gt; {
      return {
        id: idx + 1,
        name: dirsName[idx],
        pathName: _path,
        query: '',
      }
    }),
  )
}

async function updateAppConfig(fileStr, subPackage) {
  fileStr = fileStr.replace(/(subPackages[\S\s]*)window/g, `subPackages: ${JSON.stringify(subPackage)}, window`)
  await writeFile(APP_CONFIG_PATH, fileStr)
}

async function updateRouteTable(fileStr) {
  let routeTable = `
    // 自动生成, pages 文件夹新建目录，运行 npm run g
    export enum URLs {
      ${fileStr}
    }
  `
  await writeFile(URL_TABLE_PATH, routeTable)
}

async function updateProjectConfig(entrance) {
  PROJECT_CONFIG.condition.miniprogram.list = entrance
  await writeFile(PACKAGE_CONFIG_PATH, JSON.stringify(PROJECT_CONFIG, null, 2))
}

function sortDirs(dirsName) {
  const indexIdx = dirsName.findIndex((dirname) =&gt; dirname === 'index')
  if (indexIdx === -1) return dirsName.sort((a, b) =&gt; a.localeCompare(b))
  dirsName.splice(indexIdx, 1)
  dirsName = dirsName.sort((a, b) =&gt; a.localeCompare(b))
  dirsName.unshift('index')
  return dirsName
}

async function main(dirPath) {
  const baseDirsName = await readDir(dirPath)
  const target = baseDirsName.filter((dirName) =&gt; /^pages$|^package-\w+$/.test(dirName))

  // 读取APP配置文件
  let appConfigFileStr = await readFile(APP_CONFIG_PATH)
  // app.config 分包配置
  let subPackage = []

  // 生成路由表文件
  let routeTableFileStr = ''
  
  // project.config 项目快捷入口配置
  let entrance = []
  let mainEntrance = []

  for await (let i of target) {
    if (i === 'pages') {
      const dirsName = sortDirs(await readDir(path.resolve(dirPath, i)))
      appConfigFileStr = handleMainPageConfig(dirsName, appConfigFileStr)
      routeTableFileStr = handleMainRouteTable(dirsName, routeTableFileStr)
      mainEntrance = handleMainProjectConfig(dirsName, [])
    } else {
      const dirsName = sortDirs(await readDir(path.resolve(dirPath, i, 'pages')))
      subPackage = handleSubPageConfig(i, dirsName, subPackage)
      routeTableFileStr = handleSubRouteTable(i, dirsName, routeTableFileStr)
      entrance = handleSubProjectConfig(i, dirsName, entrance)
    }
  }
  updateAppConfig(appConfigFileStr, subPackage)
  updateRouteTable(routeTableFileStr)
  updateProjectConfig(mainEntrance.concat(entrance))
}

// 主函数
main(path.resolve(BASE_PATH, 'src'))

</code></pre>
<h3 id="工具脚本文件">工具脚本文件</h3>
<pre><code class="language-javascript">const path = require('path')
const fs = require('fs')

// 当前路径是文件夹
function isDir(filePath) {
  return new Promise((resolve, reject) =&gt; {
    fs.stat(filePath, (err, stats) =&gt; {
      if (err) {
        reject(err)
      } else {
        resolve(stats.isDirectory())
      }
    })
  })
}

// 读取当前文件夹目录
function readDir(filePath) {
  return new Promise((resolve, reject) =&gt; {
    fs.readdir(filePath, 'utf8', (err, dir) =&gt; {
      if (err) {
        reject(err)
      } else {
        resolve(dir)
      }
    })
  })
}

// 读取文件
function readFile(filePath) {
  return new Promise((resolve, reject) =&gt; {
    fs.readFile(filePath, (err, dir) =&gt; {
      if (err) {
        reject(err)
      } else {
        resolve(dir.toString())
      }
    })
  })
}

// 写文件
async function writeFile(filePath, fileStr) {
  return new Promise((resolve, reject) =&gt; {
    fs.writeFile(filePath, fileStr, (err, res) =&gt; {
      if (err) return reject(err)
      resolve(res)
    })
  })
}

// 文件夹扫描
async function fileScanner(filePath, fn) {
  const dir = await isDir(filePath)
  if (dir) {
    const dirs = await readDir(filePath)
    for await (const name of dirs) {
      fileScanner(path.resolve(filePath, name), fn)
    }
  } else {
    await fn(filePath)
  }
}

module.exports = {
  isDir,
  readDir,
  readFile,
  writeFile,
  fileScanner,
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ReactNative渐进式图片加载]]></title>
        <id>https://aiyou.life/post/FEu-GtOkz/</id>
        <link href="https://aiyou.life/post/FEu-GtOkz/">
        </link>
        <updated>2020-09-05T16:22:37.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在做ReactNative项目，我们的页面有很多图片，发现图片加载效果很卡顿。于是研究了一下RN下图片渐进加载。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在做ReactNative项目，我们的页面有很多图片，发现图片加载效果很卡顿。于是研究了一下RN下图片渐进加载。</p>
<!-- more -->
<h2 id="原理">原理</h2>
<p>首先给图片一个固定宽高的容器，容器中有两个透明度为0的 Image 元素， 其中一个加载缩略图，一个为原图，监听图片加载，调整透明度，给过渡动画。</p>
<h2 id="依赖">依赖</h2>
<pre><code class="language-bash">react-native-fast-image   用于缓存图片
react-spring/native   用于实现动画效果
</code></pre>
<h2 id="对比图">对比图</h2>
<figure data-type="image" tabindex="1"><img src="https://aiyou.life/post-images/1599328089874.gif" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">优化前</div>
<figure data-type="image" tabindex="2"><img src="https://aiyou.life/post-images/1599328239398.gif" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">优化后</div>
<h2 id="核心代码">核心代码</h2>
<pre><code class="language-typescript">import React, { FC } from 'react'
import { View, StyleSheet, ImageStyle, ViewStyle, animated } from 'react-native'
import FastImage, { FastImageProps } from 'react-native-fast-image'
import { animated } from 'react-spring/native'
import { useSpring } from 'react-spring'

const AnimatedFastImage = animated(FastImage)

interface ImgStyle extends ImageStyle {
  width: number | string
  height: number | string
}

interface Props extends FastImageProps {
  thumbnailSource?: FastImageProps['source']
  style: ImgStyle
  containerStyle?: ViewStyle
}

export const ProgressiveImage: FC&lt;Props&gt; = ({
  thumbnailSource,
  source,
  style,
  containerStyle,
  ...props
}) =&gt; {
  const [thumbOpStyle, setThumbOpStyle] = useSpring(() =&gt; ({ opacity: 0, config: { duration: 500 } }))
  const [imgOpStyle, setImgOpStyle] = useSpring(() =&gt; ({ opacity: 0, config: { duration: 500 } }))

  function handleThumbnailLoad() {
    setThumbOpStyle({ opacity: 1, config: { duration: 500 } })
  }

  function onImageLoad() {
    setImgOpStyle({ opacity: 1, config: { duration: 500 } })
  }

  return (
    &lt;View style={[styles.container, { width: style.width, height: style.height }, containerStyle]}&gt;
      {thumbnailSource &amp;&amp; (
        &lt;AnimatedFastImage
          {...props}
          source={thumbnailSource}
          style={[style, thumbOpStyle]}
          onLoad={handleThumbnailLoad}
          blurRadius={1}
        /&gt;
      )}
      &lt;AnimatedFastImage
        {...props}
        source={source}
        style={[styles.imageOverlay, imgOpStyle, style]}
        onLoad={onImageLoad}
      /&gt;
    &lt;/View&gt;
  )
}

const styles = StyleSheet.create({
  imageOverlay: {
    position: 'absolute',
    left: 0,
    right: 0,
    bottom: 0,
    top: 0,
  },
  container: {
    backgroundColor: '#e1e4e8',
  },
})

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多行文本溢出省略]]></title>
        <id>https://aiyou.life/post/qo35dDzbQ/</id>
        <link href="https://aiyou.life/post/qo35dDzbQ/">
        </link>
        <updated>2020-09-05T05:04:44.000Z</updated>
        <summary type="html"><![CDATA[<p>多行文本溢出省略技术是一个难题，无论是在前端还是APP端。文字何时换行，换行的是哪一个字，文字会占用几行都难以精确计算和估量。本文将探讨和实现一种相对完美的方法。</p>
]]></summary>
        <content type="html"><![CDATA[<p>多行文本溢出省略技术是一个难题，无论是在前端还是APP端。文字何时换行，换行的是哪一个字，文字会占用几行都难以精确计算和估量。本文将探讨和实现一种相对完美的方法。</p>
<!-- more -->
<h1 id="单行文本省略">单行文本省略</h1>
<p>单行文本省略较为简单，且兼容性较好。</p>
<p>要实现单行文本省略，下面CSS属性缺一不可</p>
<pre><code class="language-css">width: 100px;  // 固定宽度
overflow: hidden;   // 溢出隐藏
white-space: nowrap;    // 文字不换行
text-overflow: ellipsis;    // 文字溢出截断
</code></pre>
<h1 id="多行文本省略">多行文本省略</h1>
<p>当接到这个需求的时候，考虑到我们产品运行在微信小程序，而小程序在IOS和安卓平台都是用了webkit内核, 因而下面的代码应当在两个平台都可以很好运行。</p>
<p>webkit 内核的浏览器可以原生实现多行文本溢出省略。</p>
<pre><code class="language-css">display: -webkit-box；
-webkit-box-orient: vertical;
-webkit-line-clamp: 2;
overflow: hidden；
text-overflow: ellipsis；
</code></pre>
<p>然而事实并非如此。实际上面代码在安卓可以运行，但在IOS下则空白。<br>
<img src="https://aiyou.life/post-images/1599296417880.png" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">line-clamp兼容性</div>
<figure data-type="image" tabindex="1"><img src="https://aiyou.life/post-images/1599295340251.png" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">微信小程序运行环境</div>
<figure data-type="image" tabindex="2"><img src="https://aiyou.life/post-images/1599296818625.png" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">IOS WkWebView 基于 Webkit</div>
<p>找了半天资料，也没有找到原因。猜想可能 WkWebView 中的 webkit 版本太低的缘故。</p>
<p>既然上面的代码不能使用，只能尝试其他办法。</p>
<h2 id="js-方式">JS 方式</h2>
<p>JS计算裁剪的方式被排除了</p>
<ul>
<li>第一，这有悖于行为与展示相分离的理念</li>
<li>第二，要考虑汉字，英文字母，图标，全角半角符号等才能相对准确算出文字占用几行，要不要裁切</li>
<li>第三，我们的使用场景中要解析富文本，对于HTML标签，链接地址等要考虑的较多，实现方案较为复杂</li>
</ul>
<h2 id="css-方式">CSS 方式</h2>
<h3 id="方法一">方法一</h3>
<p>很容易写下下面这些代码，缺点是固定高度，文字数量必须超过两行，当文字只有一行或两行时，都会显示末尾的省略号。且文字超过两行，末尾的省略号有可能遮挡住一半的字符。这样的效果不是我们想要的。</p>
<pre><code class="language-css">.container {
    position: 'relative';
    width: 200px;
    height: 40px;
    line-height: 20px;
    overflow: hidden;
}
.container::after {
    content: '...';
    display: 'block';
    position: 'absolute';
    right: 0;
    bottom: 0;
}
</code></pre>
<h3 id="方法二">方法二</h3>
<p>CSS 处理的难点在于知道有没有换行，思考良久后无果，从网上找了找资料，发现一种很巧妙的办法。解决了一部分问题。</p>
<p>该方法利用浮动元素特性实现。原理很简单，但想法很独特。下面给出一个限定两行的例子。</p>
<h4 id="第一步创建如图布局">第一步：创建如图布局</h4>
<figure data-type="image" tabindex="3"><img src="https://aiyou.life/post-images/1599306945438.gif" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">第一步</div>
<pre><code class="language-html">&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;baseline&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;text&quot;&gt;这是一段很长的文本这是一段很长的文本这是一段很长的文本这是一段很长的文本&lt;/div&gt;
    &lt;div class=&quot;omit&quot;&gt;...&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-less">.container {
    background: #099;
    max-height: 40px;
    line-height: 20px;
    .baseline {
        float: left;
        width: 20px;
        height: 40px;
        background: yellow;
    }
    .text {
        float: right;
        width: calc(100% - 20px);
        background: blueviolet;
        word-break: break-all;
    }
    .omit {
        float: right;
        content: &quot;...&quot;;
        width: 20px;
        height: 20px;
        background: red;
    }
}
</code></pre>
<h4 id="第二步省略号归位">第二步：省略号归位</h4>
<figure data-type="image" tabindex="4"><img src="https://aiyou.life/post-images/1599314322562.gif" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">第二步</div>
<pre><code class="language-less">...
    .omit {
        float: right;
        content: &quot;...&quot;;
        width: 20px;
        height: 20px;
        background: red;
        + position: relative;
        + left: 100%;
        + transform: translate(-100%, -100%);
    }
...
</code></pre>
<p>这里利用 position: relative 相对父元素将自己定位到了父元素的宽度外，之后利用 transform 向上向左移动了一个自己的宽高。当只有一行时，省略号移出了视线之外，当两行时，省略号回归了正确的位置。</p>
<h4 id="第三步隐藏多余元素">第三步：隐藏多余元素</h4>
<figure data-type="image" tabindex="5"><img src="https://aiyou.life/post-images/1599315200026.gif" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">第三步</div>
<pre><code class="language-less">...
.container {
    background: #099;
    max-height: 40px;
    line-height: 20px;
    ++ overflow: hidden;
    ...
    .text {
        float: right;
        -- width: calc(100% - 20px);
        ++ width: 100%;
        ++ margin-left: -20px;
        background: blueviolet;
        word-break: break-all;
    }
...
</code></pre>
<p>这里使用 margin-left 为负，盖住了 baseline 元素。这样保证了基本布局不变，且达到了影藏无关元素的作用。由于在父元素中设定了 overflow: hidden, 清除浮动，所以父元素的背景颜色显示出来了。</p>
<h4 id="局限性">局限性</h4>
<figure data-type="image" tabindex="6"><img src="https://aiyou.life/post-images/1599316233622.gif" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">局限</div>
使用该种方式，局限在于固定高度。baseline 元素必须设定为固定高度，因而撑起了父元素的高度。
<h4 id="注意">注意</h4>
<ul>
<li>container 元素中 maxHeight/Height 必须是 LineHeight 的整数倍。倍数表示限制几行</li>
<li>container 元素中 maxHeight/Height 要与 baseline 元素的 height 保持一致</li>
<li>baseline 元素宽度要与 emit 元素宽度保持一致</li>
<li>emit 元素高度要为 container 元素的行高</li>
</ul>
<h4 id="应用案例">应用案例</h4>
<figure data-type="image" tabindex="7"><img src="https://aiyou.life/post-images/1599318337342.png" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">指尖探案小程序评论</div>
<p>对比App Store中的评论，可以看出我们的实现还是相对完美<br>
<img src="https://aiyou.life/post-images/1599318937357.jpg" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">AppStore评论</div>
<h2 id="参考">参考</h2>
<p><a href="https://juejin.im/post/5dc15b35f265da4d432a3d10#heading-9">可能是最全的 “文本溢出截断省略” 方案合集</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TS学习笔记]]></title>
        <id>https://aiyou.life/post/-d73T0KeE/</id>
        <link href="https://aiyou.life/post/-d73T0KeE/">
        </link>
        <updated>2020-09-05T04:08:59.000Z</updated>
        <summary type="html"><![CDATA[<p>很早之前写的一系列关于TypeScript的学习笔记，保存在了 Github 仓库。不是很方便查看，现迁移到Blog了</p>
]]></summary>
        <content type="html"><![CDATA[<p>很早之前写的一系列关于TypeScript的学习笔记，保存在了 Github 仓库。不是很方便查看，现迁移到Blog了</p>
<!-- more -->
<h2 id="基础类型">基础类型</h2>
<h3 id="字符串数字布尔值">字符串/数字/布尔值</h3>
<p>只需要在申明后面加 <strong>:type</strong> 即可</p>
<pre><code class="language-typescript">let str: string = '12345'

let num: number = 12345

let bool: boolean = true

</code></pre>
<h3 id="数组">数组</h3>
<p>要求数组中每一项的类别都相同</p>
<pre><code class="language-typescript">let ary: number[] = [1, 2, 3]

let ary: Array&lt;number&gt; = [1, 2, 3]
</code></pre>
<h3 id="元组">元组</h3>
<p>数组申明要求数组中每一项都相同，元组可为数组项申明不同类型</p>
<pre><code class="language-typescript">let tuple: [string, number]

tuple = ['123', 123]

tuple[2] = 234 // 正确

tuple[1] = '234' // 正确

tuple[3] = true // 错误

</code></pre>
<p>可以为没有申明的类型的数组项进行赋值，但是 <strong>赋值类型必须是申明列表中存在的类型</strong></p>
<h3 id="枚举">枚举</h3>
<p>枚举类型是 TypeScript 对 JavaScript 的扩展.</p>
<pre><code class="language-typescript">enum Color { Red = 1, Green, Blue }

let c: Color = Color.Green  // 2

let d: string = Color[2]  // 'Green'

</code></pre>
<p>默认从下标0开始编号，但是可以手动指定.</p>
<p>作用就是根据下标找值，或者根据值找下标。</p>
<h3 id="any">Any</h3>
<p>未知或者可变的变量类型由Any进行声明</p>
<pre><code class="language-typescript">let ha: any = 4

ha = '44'  // 正确

ha = true  // 正确

ha = [] // 正确

let list: any[] = [1, true, &quot;free&quot;] // 正确
</code></pre>
<p>遇到any标记的变量，编译器会跳过类型检查，所以只要在 JavaScript 中声明没问题就行</p>
<h3 id="void">Void</h3>
<p>声明为 void 类型说明该变量没有任何值，只能赋予 undefined 或者 null，这种操作没什么用</p>
<p>当函数没有返回值时，需要声明函数返回为 void</p>
<pre><code class="language-typescript">let hh: void = undefined

function warnUser(): void {
  console.log(&quot;This is my warning message&quot;);
}

</code></pre>
<h3 id="null-undefined">Null / Undefined</h3>
<p>Null / Undefined 是两个类型，申明之后只能赋值本身。。但这样做没什么用...</p>
<p>默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。</p>
<h3 id="never">Never</h3>
<p>表示永远不存在值的类型</p>
<pre><code class="language-typescript">// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
  return error(&quot;Something failed&quot;);
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
  while (true) {
  }
}
</code></pre>
<p>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。</p>
<h3 id="object">Object</h3>
<p>除number，string，boolean，symbol，null或undefined之外的类型。</p>
<h2 id="变量申明">变量申明</h2>
<p>变量申明没什么特别的，就是ES6中的知识，let,const...</p>
<p>研究一下下面这个</p>
<p>示例代码</p>
<pre><code class="language-typescript">function f([first, second]: [number, number]) {
    console.log(first);
    console.log(second);
}

const input = [1, 2]

f(input); // 报错

</code></pre>
<p>这是 TypeScript 中文网的示例代码。。结果居然报错了。。研究了一下明白了为什么。</p>
<p>首先 typescript 环境下，像 <code>const input = [1, 2]</code> 这样的定义，数组项都为数字，默认申明为<code>Array&lt;number&gt;</code>.所以相当于<code>const input: Array&lt;number&gt; = [1, 2]</code></p>
<p>看函数参数 <code>[first, second]</code> , 调用函数 <code>f(input)</code>, 这里用到了变量解构，<code>input</code>是一个申明为所有元素都为 number 的 <strong>数组</strong>。再看参数后面的类型定义，这是用 <strong>元组</strong> 形式申明传入参数的类型。。传入的参数与参数申明类型不符，所以报错。</p>
<p>正确代码</p>
<pre><code class="language-typescript">function f([first, second]: Array&lt;number&gt;) {
    console.log(first);
    console.log(second);
}

const input = [1, 2]  // 或者 const input: Array&lt;number&gt; = [1, 2]

f(input); // 正确

</code></pre>
<p>或者</p>
<pre><code class="language-typescript">function f([first, second]: [number, number]) {
    console.log(first);
    console.log(second);
}

const input: [number, number] = [1, 2]

f(input); // 正确

</code></pre>
<h3 id="对象解构">对象解构</h3>
<h4 id="属性值重命名">属性值重命名</h4>
<p>示例代码:</p>
<pre><code class="language-typescript">const { name: myName }: { name: string, age: number } = { name: 'han', age: 12 }
</code></pre>
<p>这里很乱，逐一分析一下:</p>
<p>首先不含类型检查的最基本的对象变量解构是这样的(ES6语法)</p>
<pre><code class="language-typescript">const { name } = { name: 'han', age: 12 }

// 上面这一行相当于
const { name: name } = { name: 'han', age: 12 }
</code></pre>
<p>如果要对name值重命名，则需要在 name 后加 :</p>
<pre><code class="language-typescript">const { name: myName } = { name: 'han', age: 12 }
</code></pre>
<p>TypeScript 在ES6基础上，添加了类型检查，也就是上面的示例代码。</p>
<p>类型检查不能只检查自己需要的数据，而是检查所有要解构的对象，所以<code>age: number</code>这里必不可少</p>
<p><strong>在使用对象解构前，一定要牢记ES6的解构语法，在此基础上，再使用 TypeScript 的类型限制</strong></p>
<h4 id="展开操作符">展开操作符</h4>
<p>使用与ES6一致</p>
<p>看个小例子</p>
<pre><code class="language-typescript">class C {
  p = 12;
  m() {
  }
}

let c = new C();
let clone = { ...c };
clone.p;  // ok
clone.m();  // error
</code></pre>
<p>当展开操作符展开一个对象时，会丢失方法。展开操作符展开的是可枚举属性。</p>
<h2 id="接口">接口</h2>
<p>原文给出两段代码</p>
<pre><code class="language-typescript">function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label);
}

let myObj = { size: 10, label: &quot;Size 10 Object&quot; };

printLabel(myObj);

</code></pre>
<p>接口版本的</p>
<pre><code class="language-typescript">interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

let myObj = {size: 10, label: &quot;Size 10 Object&quot;};
printLabel(myObj);

</code></pre>
<p>首先这里有疑问，在上面那种方式可以实现类型检查的情况下，为什么要推出接口这个新概念?先接着往下看</p>
<h3 id="可选属性">可选属性</h3>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: &quot;white&quot;, area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({color: &quot;black&quot;});  // ok

let mySquare = createSquare({});  // ok

let mySquare = createSquare();  // error

</code></pre>
<p>首先看调用这里，传参空对象是可以的，因为接口规定了我们 color, width 可传可不传。。但是没告诉我们参数是可选的，所以不传参会报错。。</p>
<p>改造成如下代码</p>
<pre><code class="language-typescript">function createSquare(config: SquareConfig = {}): {color: string; area: number} { 
  ...
}

let mySquare = createSquare();  // ok

</code></pre>
<p>初次看这个函数是有点懵逼的。<code>function createSquare(config: SquareConfig): {color: string; area: number}</code>中的<code>: {color: string; area: number}</code>是什么观察了半天？各种测试之后，才想起，这是规定返回值的类型的...这种函数多练练多写写就好了</p>
<p>再来看我们第一部分给出的问题，为什么要推出接口这个概念，这里还不好说，但是可以不用接口的方式实现上面的函数</p>
<pre><code class="language-typescript">function createSquare(config: {color?: string, width?: number} = {}): {color: string; area: number} { 
  ...
}

let mySquare = createSquare({color: &quot;red&quot;});  // ok

let mySquare = createSquare({});  // ok

let mySquare = createSquare();  // ok

</code></pre>
<h3 id="只读属性">只读属性</h3>
<pre><code class="language-typescript">interface Point {
  readonly x: number;
  readonly y: number;
}

let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
</code></pre>
<p>只读属性只能在对象创建的时候给出初始值，后续就没办法进行修改。</p>
<p>我们接着改造上面的函数</p>
<pre><code class="language-typescript">interface SquareConfig {
  readonly color?: string;
  readonly width?: number;
}

function createSquare(config: SquareConfig = {}): { color: string; area: number } {
  let newSquare = { color: &quot;white&quot;, area: 100 };
  if (config.color) {
    config.color = &quot;red&quot;  // error
    newSquare.color = config.color
  }
  if (config.width) {
    config.width = 200  // error
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}
</code></pre>
<p>我们将接口中的 color 和 width 都配置成 只读 。所以当在函数体中进行修改参数时会报错。</p>
<p>那我们怎么使用无接口的方法达到同样的效果(配置属性不可修改)?</p>
<p>我们知道原生JS中，每个属性都包含了一个描述符，描述符中有四个配置项，可配置属性行为</p>
<blockquote>
<ul>
<li>configurable: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li>
<li>enumerable: 表示能否通过for-in循环返回属性。</li>
<li>writable: 表示能否修改属性的值。</li>
<li>value: 包含这个属性的数据值。</li>
</ul>
</blockquote>
<p>我们利用其中的 <strong>writable</strong> 是否可以实现呢?</p>
<p>看下面的代码</p>
<pre><code class="language-typescript">function createSquare(config: {color?:string,width?:number} = {}): { color: string; area: number } {
  let newSquare = { color: &quot;white&quot;, area: 100 };

  Object.defineProperty(config, &quot;color&quot;, { writable: false})
  Object.defineProperty(config, &quot;width&quot;, { writable: false })
  
  if (config.color) {
    config.color = &quot;red&quot;
    newSquare.color = config.color
  }
  if (config.width) {
    config.width = 200
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

createSquare({ color: &quot;black&quot; }); // error

createSquare({})  // ok

createSquare()  // ok
</code></pre>
<p>代码可正确通过TypeScript的编译，但是在JavaScript代码运行时会出错。(TypeScript在编译时期检查错误，检查的是语法错误。我们写的代码没有语法错误，所以可以通过编译)</p>
<p>可以看到，虽然这里实现了与接口基本相同的效果，但是编译阶段没办法捕捉到错误。</p>
<p>此外还有只读类型数组</p>
<pre><code class="language-typescript">let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray&lt;number&gt; = a;

a.push(1) // ok
ro.push(2)  // error

let b = ro as Array&lt;number&gt;

b.push(1) // ok
</code></pre>
<p>数组设置成只读的之后，将不能再使用原来操作数组的各种方法。但是进行类型断言(类型断言是一种强制转化的机制，TypeScript认为人比程序更了解这个变量是什么类型)之后就又可以了</p>
<h3 id="额外的类型检查">额外的类型检查</h3>
<p>还以上面的代码为例</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  ...
}

let mySquare = createSquare({ height: 22 });  // 报错

</code></pre>
<p><s>向函数中传入了接口规定的属性以外的属性，会报错。这其实很好理解是为什么，没有经过类型检查等手段就将一些变量带入函数的运行环境中，那要 TypeScript 有什么用呢? TypeScript 最大的优点就是将所有变量可以掌控，哪一个阶段数据是什么状态都是明明白白的。</s></p>
<p>那怎么解决上面的这个问题 ?</p>
<p>可以使用类型断言，将我们传入的参数断言成接口类型的数据</p>
<pre><code class="language-typescript">let mySquare = createSquare({ height: 22 } as SquareConfig);  
</code></pre>
<p><strong>这里注意为什么将{ height: 22} 转化成 SquareConfig 类型之后就能用了，明明 SquareConfig 中并不存在 height 属性。这是因为类型断言不进行特殊的数据检查和解构</strong></p>
<p>原文中还给出了&quot;字符串索引签名&quot;这种方式</p>
<pre><code class="language-typescript">interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
</code></pre>
<p>表示SquareConfig可以有任意数量的属性，并且只要它们不是 color 和 width，那么就无所谓它们的类型是什么</p>
<p>&quot;字符串索引签名&quot;这里先放着，之后再学习</p>
<p>最后也是最不推荐的一种是绕过检查</p>
<pre><code class="language-typescript">createSquare({ colour: &quot;red&quot;, width: 100 });  // 报错

let squareOptions = { colour: &quot;red&quot;, width: 100 };
let mySquare = createSquare(squareOptions);   // 正确
</code></pre>
<p>这里为什么能绕过检查????原文解释是这样的<strong>因为 squareOptions不会经过额外属性检查，所以编译器不会报错</strong>.这里保留疑问..</p>
<p>请教了大神之后明白了 <a href="part-3(1)-add.md">TypeScript绕过编译器检查的一点困惑</a></p>
<h3 id="函数类型">函数类型</h3>
<pre><code class="language-typescript">interface SearchFunc {
  (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source, subString) {
  let result = source.search(subString);
  return result &gt; -1;
}

// 代码相当于
let mySearch: (source: string, subString: string) =&gt; boolean = function (source, subString) : boolean {
  let result = source.search(subString);
  return result &gt; -1;
}

// (source: string, subString: string) =&gt; boolean 也是规范函数写法的一种形式
</code></pre>
<p>mySearch函数 是 SearchFunc 类型的，SearchFunc 接口中定义了必须要传入的参数及参数类别，以及返回值的类别。那示例中函数定义中的参数类型指定显得有些多余了，去掉也是没错的</p>
<pre><code class="language-typescript">mySearch = function(source, subString) {
  ...
}
</code></pre>
<p>另外定义函数的函数参数名称是可以改变的,函数的参数会逐个进行检查,位置对了就行</p>
<pre><code class="language-typescript">mySearch = function(sur, sub) {
  ...
}
</code></pre>
<p>那这里传入一个需要变量解构的对象，接口该怎么定义?</p>
<p>如下</p>
<pre><code class="language-typescript">function test({ sid }) {
  ...
}

test({ sid: '123', num: 123 })
</code></pre>
<p>定义如下:</p>
<pre><code class="language-typescript">interface Sid {
  sid: string,
  [propName: string]: any;
}

interface Test {
  (sid: Sid, num: number): number
}

const test: Test = function ({ sid }, num) {
  return Number.parseInt(sid) + num
}

test({ sid: '123', ha: '234' }, 2)
</code></pre>
<h3 id="可索引的类型">可索引的类型</h3>
<pre><code class="language-typescript">interface StringArray {
  [index: number]: string;
}

let myArray: StringArray;
myArray = [&quot;Bob&quot;, &quot;Fred&quot;];

let myStr: string = myArray[0];
</code></pre>
<p>表示了当用 number 去索引 StringArray 时会得到 string 类型的返回值。这就相当于一个字符串数组</p>
<p>这种东西定义成一个数组不就完了?为什么要弄出这种东西?</p>
<h3 id="类类型">类类型</h3>
<h4 id="实现接口">实现接口</h4>
<p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约</p>
<pre><code class="language-typescript">interface ClockInterface {
  currentTime: Date;
  setTime(d: Date): void;
}

class Clock implements ClockInterface {
  currentTime: Date;
  constructor() {
    this.currentTime = new Date()
  }
  setTime(d: Date) {
    this.currentTime = d;
  }
}
</code></pre>
<p><s>接口中描述的数据和方法挂载到原型上</s></p>
<p>接口中定义的属性将在类中属性上定义。定义的方法将挂载到原型上。</p>
<h4 id="类静态部分与实例部分的区别">类静态部分与实例部分的区别</h4>
<pre><code class="language-typescript">// 函数接口
interface ClockConstructor {
    // 定义了一个构造函数，返回 ClockInterface 类型数据
    new (hour: number, minute: number): ClockInterface;
}

// 类接口
interface ClockInterface {
    // 定义了一个继承类需要实现的函数。
    tick():void;
}

// 参数 ctor 为构造函数
function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

// 继承类需要实现 tick 函数
class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;beep beep&quot;);
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;tick tock&quot;);
    }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
</code></pre>
<p>两个类均继承自 ClockInterface , 所以他们应当实现接口中的 tick 函数。</p>
<p>观察函数 createClock</p>
<p>参数<code>ctor: ClockConstructor</code>相当于<code>const ctor : ClockConstructor = DigitalClock</code></p>
<p>于是再看 接口ClockConstructor，接口中表明，实现该接口的函数需要返回 ClockInterface 的一个实例</p>
<p>直接定义一个接口规范类中的静态部分和实例部分不好实现。代码中使用了两个接口实现分别规范这两个部分。</p>
<p>ClockInterface 接口直接规范了实例部分函数</p>
<p>ClockConstructor 接口规范了构造函数，规范了静态部分</p>
<h3 id="继承接口">继承接口</h3>
<p>看代码、很容易明白</p>
<pre><code class="language-typescript">interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
square.penWidth = 5.0;
</code></pre>
<h3 id="混合类型">混合类型</h3>
<p>看代码</p>
<pre><code class="language-typescript">interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = &lt;Counter&gt;function (start: number) { };
    // 相当于 let counter = function (start: number) { } as Counter;
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
</code></pre>
<p>接口中定义了三种类型，用在函数上，函数应当包含一个 number 参数，返回 string 类型数据，观察 getCounter 函数，函数内部定义了一个名为 counter 函数，函数被强转为 Counter 类型，所以可以挂载在 Counter 接口中定义的 reset 和 interval</p>
<h3 id="接口继承类">接口继承类</h3>
<p>看代码</p>
<pre><code class="language-typescript">class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class TextBox extends Control {
    select() { }
}

// 错误：“Image”类型缺少“state”属性。
class Image implements SelectableControl {
    select() { }
}

class Location {

}
</code></pre>
<p>原文说到&quot;接口继承类时，会继承其的 private 和 protected 成员&quot;。实际上将上面代码 Control 类中的 private 改为 public ,Image 类也会报错。</p>
<h2 id="类">类</h2>
<p>先看代码</p>
<pre><code class="language-typescript">class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log(&quot;Slithering...&quot;);
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log(&quot;Galloping...&quot;);
        super.move(distanceInMeters);
    }
}

let sam = new Snake(&quot;Sammy the Python&quot;);
let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);

sam.move();
tom.move(34);
</code></pre>
<p>像是 Java 和 ES6 语法的混合。很好看懂</p>
<p>定义到 constructor 中的属性，需要在 class 的大括号内表明是什么类型的</p>
<h2 id="private-修饰符">private 修饰符</h2>
<p>私有属性修饰符。被修饰属性只能在当前类中被访问。</p>
<pre><code class="language-typescript">class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super(&quot;Rhino&quot;); }
}

class Employee {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

let animal = new Animal(&quot;Goat&quot;);
let rhino = new Rhino();
let employee = new Employee(&quot;Bob&quot;);

animal = rhino;
animal = employee; // 错误: Animal 与 Employee 不兼容.
</code></pre>
<p>只有当 私有属性 来源于同一处时，才兼容</p>
<h2 id="protected-修饰符">protected 修饰符</h2>
<p>保护属性修饰符。被修饰属性除了能在当前类被访问，还可以被派生类访问</p>
<pre><code class="language-typescript">class Person {
    protected name: string;
    protected constructor(theName: string) { this.name = theName; }
}

// Employee 能够继承 Person
class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);
let john = new Person(&quot;John&quot;); // 错误: 'Person' 的构造函数是被保护的.

</code></pre>
<h2 id="public-修饰符">public 修饰符</h2>
<p>在哪都能被访问到。没有修饰符时，默认为 public</p>
<h2 id="readonly-修饰符">readonly 修饰符</h2>
<p>数据只读。只读属性必须在声明时或构造函数里被初始化</p>
<h2 id="getset-存取器">get/set 存取器</h2>
<p>简单看个例子就好</p>
<pre><code class="language-typescript">let passcode = &quot;secret passcode&quot;;

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) {
            this._fullName = newName;
        }
        else {
            console.log(&quot;Error: Unauthorized update of employee!&quot;);
        }
    }
}

let employee = new Employee();
employee.fullName = &quot;Bob Smith&quot;;
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>
<h2 id="静态属性">静态属性</h2>
<p>静态属性存在于类本身上面而不是类的实例上。</p>
<pre><code class="language-typescript">class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        let xDist = (point.x - Grid.origin.x);
        let yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

let grid1 = new Grid(1.0);  // 1x scale
let grid2 = new Grid(5.0);  // 5x scale

console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
</code></pre>
<p>改写成我们常见的 JavaScript 形式</p>
<pre><code class="language-javascript">function Grid (scale) {
  this.scale = scale
}

Grid.origin = { x:0, y:0} // 这个就是 TypeScript 中的静态属性

Grid.prototype.calculateDistanceFromOrigin = function (point) {
  ...
}

</code></pre>
<h2 id="抽象类">抽象类</h2>
<p>抽象类做为其它派生类的基类使用</p>
<pre><code class="language-typescript">abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log('Department name: ' + this.name);
    }

    abstract printMeeting(): void; // 必须在派生类中实现
}

class AccountingDepartment extends Department {

    constructor() {
        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
    }

    printMeeting(): void {
        console.log('The Accounting Department meets each Monday at 10am.');
    }

    generateReports(): void {
        console.log('Generating accounting reports...');
    }
}

let department: Department; // 允许创建一个对抽象类型的引用
department = new Department(); // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
department.printName();
department.printMeeting();
department.generateReports(); // 错误: 方法在声明的抽象类中不存在
</code></pre>
<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现.相对于接口中定义的方法，抽象类定义抽相关方法，需要加 abstract 关键字。</p>
<p>接口与抽象类的区别:接口中的定义必须在其继承中进行实现，接口中本身不包含实现，只有定义。抽象类中的普通函数需要具体实现，抽象函数则在派生各类中进行实现。</p>
<h2 id="函数">函数</h2>
<pre><code class="language-typescript">let myAdd: (x: number, y: number) =&gt; number = function (x: number, y: number): number { return x + y; };
</code></pre>
<p>看教程中给出的这个实例，不是特别容易看懂</p>
<p>以等号为分界线。左边定义了一个变量 myAdd , 冒号后表明了类型:两个 number 参数和返回 number 类型数据</p>
<p><strong>在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</strong></p>
<p>完整的一个函数应当是上面这种定义，但可以省略部分</p>
<p>代码如下:</p>
<pre><code class="language-typescript">// 由右边可以推断左边
let myAdd = function(x: number, y: number): number { return x + y; };

// 由左边可以推断右边
let myAdd: (baseValue: number, increment: number) =&gt; number =
    function(x, y) { return x + y; };
</code></pre>
<h3 id="剩余参数">剩余参数</h3>
<pre><code class="language-typescript">function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);
}

let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName;
</code></pre>
<p>注意与 ES6 区别在于需要规范 数组类型</p>
<h3 id="this">this</h3>
<p>直接调用 this 时注意 this 为 any 类型。需要手动指定一下 this 的类型</p>
<p>实例如下</p>
<pre><code class="language-typescript">interface Card {
    suit: string;
    card: number;
}
interface Deck {
    suits: string[];
    cards: number[];
    createCardPicker(this: Deck): () =&gt; Card;
}
let deck: Deck = {
    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],
    cards: Array(52),
    // NOTE: The function now explicitly specifies that its callee must be of type Deck
    createCardPicker: function(this: Deck) {
        return () =&gt; {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit);
</code></pre>
<p>文档中说直接调用 this 会报错，但是我在实际测试中并没有发现这个问题...实例代码是处理 this 之后的代码。可以 看到手动指定了一波this是什么</p>
<h3 id="函数重载">函数重载</h3>
<p>传统的面向对象编程语言中，重载概念是:在函数名相同的情况下，根据参数个数、参数类型不同的情况下调用不同的函数。</p>
<p>但在 JavaScript 中，函数名相同的话，会取最后定义的函数。</p>
<p>TypeScript 中函数重载是 申明了相同函数名称，只是参数类型、个数、返回类型不同。具体函数实现还是只有一个。</p>
<pre><code class="language-typescript">let suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];

// 定义了两种函数
// {suit: string; card: number; }[] 表示数组每一项都是 包含 suit 和 card 的对象
function pickCard(x: {suit: string; card: number; }[]): number;

function pickCard(x: number): {suit: string; card: number; };

// 函数具体实现
function pickCard(x): any {

    if (typeof x == &quot;object&quot;) {
        let pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
    }

    else if (typeof x == &quot;number&quot;) {
        let pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
    }
}

let myDeck = [{ suit: &quot;diamonds&quot;, card: 2 }, { suit: &quot;spades&quot;, card: 10 }, { suit: &quot;hearts&quot;, card: 4 }];
let pickedCard1 = myDeck[pickCard(myDeck)];

alert(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);

let pickedCard2 = pickCard(15);
alert(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit);
</code></pre>
<h2 id="泛型">泛型</h2>
<h3 id="泛型变量">泛型变量</h3>
<p>先看例子</p>
<pre><code class="language-typescript">function Test( ary: any ): any {
  return ary
}
</code></pre>
<p>这个函数隐藏了一些信息。我们传入一些参数，并不知道函数会返回哪些类型的数据。</p>
<p>泛型就是解决这个问题的</p>
<p>再看用泛型改写之后的例子</p>
<pre><code class="language-typescript">function Test&lt;T&gt; (ary: T): T {
  return ary
}
</code></pre>
<p>T不指代具体的类型，只表明类型一致。</p>
<p>函数调用示例</p>
<pre><code class="language-typescript">const t = Test&lt;string&gt;(&quot;abcd&quot;)

// 省略写法如下
const t2 = Test(&quot;abcd&quot;)
</code></pre>
<p>相较于 any, 利用泛型可以明确返回什么类型数据</p>
<p>加上 &lt;&gt; 之后，很容易和 类型断言 混了，所以平时用 类型断言 时，用 as 形式</p>
<h3 id="泛型接口">泛型接口</h3>
<pre><code class="language-typescript">// 代码1
interface GenericIdentityFn {
    &lt;T&gt;(arg: T): T;
}

function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn = identity;
myIdentity(2)

// 代码2
interface GenericIdentityFn&lt;T&gt; {
    (arg: T): T;
}

function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn&lt;number&gt; = identity;
myIdentity(2)
</code></pre>
<p>代码1 中可以根据传入的参数自动推断出 T 是什么类型的</p>
<p>代码2 相较于代码1 泛型参数当作整个接口的一个参数。在定义 myIdentity 时就指定 T 是什么类型，相对来说 代码2更清晰</p>
<h3 id="泛型类">泛型类</h3>
<p>原文给出的代码并不能正确运行，我添加了一些内容</p>
<pre><code class="language-typescript">const parm = '123'
class GenericNumber&lt;T&gt; {
  zeroValue: T;
  add: (x: T, y: T) =&gt; T;
  static n: T = &lt;T&gt;(parm)   // 报错
  constructor ( n: T) {
    this.zeroValue = n
    this.add = function (x, y) {
      return &lt;T&gt;(x)
    }
  }
}

let myGenericNumber = new GenericNumber&lt;number&gt;(1);
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function (x, y) { return x + y; };
</code></pre>
<p>其实到这里就可以看出，泛型其实就是统一类型用的。</p>
<p>泛型类指的是实例部分的类型，类的静态属性不能使用泛型类型</p>
<h3 id="泛型约束">泛型约束</h3>
<pre><code class="language-typescript">interface Lengthwise {
    length: number;
}

function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
</code></pre>
<p>如代码所示。泛型约束规范传入的 T 类型具有什么样的特征。示例代码需要传入具有 length 属性的类型数据</p>
<h3 id="在泛型中使用类类型">在泛型中使用类类型</h3>
<p>看代码</p>
<pre><code class="language-typescript">class BeeKeeper {
    hasMask: boolean;
}

class ZooKeeper {
    nametag: string;
}

class Animal {
    numLegs: number;
}

class Bee extends Animal {
    keeper: BeeKeeper;
}

class Lion extends Animal {
    keeper: ZooKeeper;
}

function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A {
    return new c();
}

createInstance(Lion).keeper.nametag;  // typechecks!
createInstance(Bee).keeper.hasMask;   // typechecks!
</code></pre>
<p>首先代码定义了5个类，类中分别定义了属性(示例代码不完整，缺 constructor).</p>
<p>观察 Bee 和 Lion，可以发现两者均继承自 Animal 类，由此，二者均可以调用 Animal 类中的公有属性 numLegs。再看 Bee 中的  keep , 数据类型为 BeeKeeper, 由此 由Bee 创建的实例可以通过 keeper 来调用 BeeKeeper 中的数据。Lion同理</p>
<p>再看 createInstance 函数，使用泛型约束 传入的类型必须具有 Animal 类中的 numLegs 属性。因为 Bee 和 Lion 均继承自 Animal，所有都有这个属性。看函数参数c是一个 A类型的构造函数</p>
<h2 id="枚举-2">枚举</h2>
<p><a href="part-1.md">基础类型</a> 中简单介绍了枚举类型。</p>
<p>看代码</p>
<pre><code class="language-typescript">enum Color {
  Green,
  Blue,
  Red
}
</code></pre>
<p>使用 enum 关键字定义一个 枚举类型 数据结构。</p>
<p>使用示例:</p>
<pre><code class="language-typescript">const red: string = Color[2]

const color: number = Color.Red
</code></pre>
<p>如上的定义 Color 代码，默认使用 0,1,2...递增编号。也可以手动指定编号</p>
<p>如下</p>
<pre><code class="language-typescript">enum Color {
  Green= 2,
  Blue= 4,
  Red
}
</code></pre>
<p>原文代码中给出这样一个例子</p>
<pre><code class="language-typescript">enum Response {
  No = 0,
  Yes = 1,
}

function respond(recipient: string, message: Response): void {
  // ...
}

respond(&quot;Princess Caroline&quot;, Response.Yes)

</code></pre>
<p>尝试将函数参数中的 Response 改为 number, 结果还是正确的</p>
<pre><code class="language-typescript">const message: Response = 1
</code></pre>
<p>这就说明<strong>数字类型与枚举类型兼容</strong></p>
<h3 id="字符串枚举">字符串枚举</h3>
<p>上面是使用数字编号进行引索，实际还可以使用字符串枚举</p>
<pre><code class="language-typescript">enum Color {
  Green='This is green',
  Blue='This is blue',
  Red='this is red'
}
</code></pre>
<h3 id="计算的和常量成员">计算的和常量成员</h3>
<pre><code class="language-typescript">enum FileAccess {
    None,
    Read = 1 &lt;&lt; 1,
    Write = 1 &lt;&lt; 2,
    ReadWrite  = Read | Write,
    G = &quot;123&quot;.length
}
</code></pre>
<p><code>&lt;&lt;</code>是 js 中的位移运算符， <code>|</code> 是或运算符</p>
<h2 id="类型推论">类型推论</h2>
<h3 id="最佳通用类型">最佳通用类型</h3>
<p>看下面的例子</p>
<pre><code class="language-typescript">let x = [1, '2']  // 正确

x = [true, '3'] // 错误
</code></pre>
<p>定义时没有类型，编译器会自动推断 x 是什么类型。</p>
<p>代码中 x 被推断为 元组 <code>[number, string]</code>, 所以 x 赋值 <code>[true, '3']</code> 失败</p>
<p>再看这个</p>
<pre><code class="language-typescript">let zoo = [new Rhino(), new Elephant(), new Snake()];
</code></pre>
<p>会被推断为联合数组类型</p>
<p>相当于</p>
<pre><code class="language-typescript">let zoo:(Rhino, Elephant, Snake)[] = [new Rhino(), new Elephant(), new Snake()];
</code></pre>
<h2 id="类型兼容性">类型兼容性</h2>
<p>TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。</p>
<p>还是给一些实例代码自己看</p>
<pre><code class="language-typescript">// 案例1
interface Named {
    name: string;
}

class Person {
    name: string;
}

let p: Named;
p = new Person(); // 正确

// 案例2
interface Named {
    name: string;
}

let x: Named;
let y = { name: 'Alice', location: 'Seattle' };
x = y;

// 案例3
let x = (a: number) =&gt; 0;
let y = (b: number, s: string) =&gt; 0;

y = x; // 正确
x = y; // 错误

// 案例4
interface Named {
    name: string;
}

class Person {
    name: number;
}

let p: Named;
p = new Person(); // 错误

</code></pre>
<p>案例1 中 Named 接口与 Person 类具有相同的组成结构，所以允许赋值</p>
<p>案例2 中 <code>{ name: 'Alice', location: 'Seattle' }</code>中包含了 x 中需要的 name 属性，所以允许赋值</p>
<p>案例3 中 函数参数 比较二者对应位置的参数类型是否相同。</p>
<p>x 函数的参数类型都能在 y 函数中找到对应类型。所以可以兼容。这里注意与 案例2 的区别，案例2 是右边多，但桉树这里是左边多</p>
<p>案例4 中 虽然二者都有 name 属性，但类型不一致，所以不兼容</p>
<h3 id="枚举-3">枚举</h3>
<p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。</p>
<h3 id="类-2">类</h3>
<p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 <strong>比较两个类类型的对象时，只有实例的成员会被比较</strong>。 静态成员和构造函数不在比较的范围内。</p>
<p>实例部分是只有在创建对象时，才初始化的数据，静态部分就是将属性直接挂在到构造函数上(在 TypeScript 中静态部分使用关键字 static 标识)。</p>
<pre><code class="language-typescript">class Animal{
  name: string
  static age: number = 12
  constructor (n: string) {
    this.name = n
  }
  setName (name: string) {
    this.name = name
  }
}

class Person{
  name: string
  static aged: number = 100
  constructor(n: string, age?: number ) {
    this.name = n
  }
  setName (name: string) {
    this.name = name
  }
}

let an: Animal = new Animal('1')
let pn: Person = new Person('2')

pn = an // 正确
</code></pre>
<p>注意上面代码中 name 属性实际是 public 类型，当改为 private 或者 protected 时就报错了。但如果 Animal 和 Person 类中的 name 均继承自父类，那么就可以又兼容了。</p>
<h2 id="高级类型">高级类型</h2>
<h3 id="交叉类型">交叉类型</h3>
<p>这种类型实际中没见过用。。这里还是放一下代码，自己看</p>
<pre><code class="language-typescript">function extend&lt;T, U&gt;(first: T, second: U): T &amp; U {
    let result = &lt;T &amp; U&gt;{};
    for (let id in first) {
        (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];
    }
    for (let id in second) {
        if (!result.hasOwnProperty(id)) {
            (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id];
        }
    }
    return result;
}

class Person {
    constructor(public name: string) { }
}
interface Loggable {
    log(): void;
}
class ConsoleLogger implements Loggable {
    log() {
        // ...
    }
}
var jim = extend(new Person(&quot;Jim&quot;), new ConsoleLogger());
var n = jim.name;
jim.log();
</code></pre>
<p>看一下还是很容易理解的</p>
<p>用 ES6 改写一下</p>
<pre><code class="language-typescript">class Person {
  constructor (name) {
    this.name = name
  }
}

class ConsoleLogger {
  log () {
    // ...
  }
}

function extend (obj1, obj2) {
  const result = {}
  for (let i in obj1) {
    result[i] = obj1[i]
  }
  for (let i in obj2) {
    result[i] = obj2[i]
  }
  return result
}

</code></pre>
<p>可以看到，代码实际在 extend 函数中创建了一个对象，该对象集合了 obj1,obj2 中所有可遍历的属性</p>
<h3 id="联合类型">联合类型</h3>
<p>联合类型表示一个值可以是几种类型之一。 用竖线 | 分隔每个类型，所以 number | string | boolean 表示一个值可以是 number， string，或 boolean。</p>
<pre><code class="language-typescript">interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}

let pet = getSmallPet();
pet.layEggs(); // 正确
pet.swim();    // 失败
</code></pre>
<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>
<h3 id="类型保护与区分类型">类型保护与区分类型</h3>
<p>看示例代码</p>
<pre><code class="language-typescript">let pet = getSmallPet();

// 每一个成员访问都会报错,因为我们只能访问此联合类型的所有类型里共有的成员
if (pet.swim) {
    pet.swim();
}
else if (pet.fly) {
    pet.fly();
}

</code></pre>
<p>如果想要访问到的话，需要进行 类型断言</p>
<pre><code class="language-typescript">let pet = getSmallPet();

if ((&lt;Fish&gt;pet).swim) {
    (&lt;Fish&gt;pet).swim();
}
else {
    (&lt;Bird&gt;pet).fly();
}
</code></pre>
<h3 id="用户自定义的类型保护">用户自定义的类型保护</h3>
<p>如何在类型检查后，能够清楚的知道是什么类型呢?</p>
<p>看下面代码</p>
<pre><code class="language-typescript">function isFish(pet: Fish | Bird): pet is Fish {
    return (&lt;Fish&gt;pet).swim !== undefined;
}

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}

</code></pre>
<p>pet is Fish就是类型谓词。谓词为 parameterName is Type这种形式</p>
<p>如上代码只能识别 Fish, 如果要识别 Bird 还需要写个函数</p>
<pre><code class="language-typescript">function isBird(pet: Fish | Bird): pet is Bird {
    return (&lt;Bird&gt;pet).fly !== undefined;
}
</code></pre>
<p>这样代码量增加了好多。于是有了下面的 typeof 类型 保护</p>
<h3 id="typeof-类型保护">typeof 类型保护</h3>
<pre><code class="language-typescript">function padLeft(value: string, padding: string | number) {
    if (typeof padding === &quot;number&quot;) {
        return Array(padding + 1).join(&quot; &quot;) + value;
    }
    if (typeof padding === &quot;string&quot;) {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
</code></pre>
<p>&quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;</p>
<h3 id="instanceof-类型保护">instanceof 类型保护</h3>
<p>与 typeof 相似</p>
<pre><code class="language-typescript">interface Padder {
    getPaddingString(): string
}

class SpaceRepeatingPadder implements Padder {
    constructor(private numSpaces: number) { }
    getPaddingString() {
        return Array(this.numSpaces + 1).join(&quot; &quot;);
    }
}

class StringPadder implements Padder {
    constructor(private value: string) { }
    getPaddingString() {
        return this.value;
    }
}

function getRandomPadder() {
    return Math.random() &lt; 0.5 ?
        new SpaceRepeatingPadder(4) :
        new StringPadder(&quot;  &quot;);
}

// 类型为SpaceRepeatingPadder | StringPadder
let padder: Padder = getRandomPadder();

if (padder instanceof SpaceRepeatingPadder) {
    padder; // 类型细化为'SpaceRepeatingPadder'
}
if (padder instanceof StringPadder) {
    padder; // 类型细化为'StringPadder'
}
</code></pre>
<h3 id="类型别名">类型别名</h3>
<p>类型别名会给一个类型起个新名字<br>
看例子</p>
<pre><code class="language-typescript">type Name = string;
type NameResolver = () =&gt; string;
type NameOrResolver = Name | NameResolver;
type Container&lt;T&gt; = { value: T };
type Tree&lt;T&gt; = {
    value: T;
    left?: Tree&lt;T&gt;;
    right?: Tree&lt;T&gt;;
}

type Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;

</code></pre>
<p>与接口区别:</p>
<p>1、类型别名不能被 extends和 implements</p>
<p>2、接口创建了一个新的名字，可以在其它任何地方使用，类型别名并不创建新名字</p>
<h3 id="this多态">this多态</h3>
<pre><code class="language-typescript">class BasicCalculator {
    public constructor(protected value: number = 0) { }
    public currentValue(): number {
        return this.value;
    }
    public add(operand: number): this {
        this.value += operand;
        return this;
    }
    public multiply(operand: number): this {
        this.value *= operand;
        return this;
    }
    // ... other operations go here ...
}

let v = new BasicCalculator(2)
            .multiply(5)
            .add(1)
            .currentValue();

class ScientificCalculator extends BasicCalculator {
    public constructor(value = 0) {
        super(value);
    }
    public sin() {
        this.value = Math.sin(this.value);
        return this;
    }
    // ... other operations go here ...
}

let v = new ScientificCalculator(2)
        .multiply(5)
        .sin()
        .add(1)
        .currentValue();

</code></pre>
<h3 id="索引类型">索引类型</h3>
<pre><code class="language-typescript">function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] {
  return names.map(n =&gt; o[n]);
}

interface Person {
    name: string;
    age: number;
}
let person: Person = {
    name: 'Jarid',
    age: 35
};
let strings: string[] = pluck(person, ['name']); // ok, string[]
</code></pre>
<p><strong>keyof T</strong> 索引类型查询操作符。对于任何类型 T， keyof T的结果为 T上已知的公共属性名的联合</p>
<p>例如:</p>
<pre><code class="language-typescript">let personProps: keyof Person; // 'name' | 'age'
</code></pre>
<h3 id="映射类型">映射类型</h3>
<p>用处在于 将一个已知的类型每个属性都变为可选的</p>
<pre><code class="language-typescript">type Readonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P];
}
type Partial&lt;T&gt; = {
    [P in keyof T]?: T[P];
}
type PersonPartial = Partial&lt;Person&gt;;
type ReadonlyPerson = Readonly&lt;Person&gt;;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用树莓派搭建个人服务器]]></title>
        <id>https://aiyou.life/post/4xGLEq7xe/</id>
        <link href="https://aiyou.life/post/4xGLEq7xe/">
        </link>
        <updated>2019-11-21T02:41:18.000Z</updated>
        <summary type="html"><![CDATA[<p>大学时用的腾讯云优惠到期了，续费要每个月60多块钱，有点肉疼。因而买了一块树莓派，想要研究一下怎么将他搞成一个服务器。拖拉了几个月，最近总算是搞好了。本文将介绍一下我的搭建过程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>大学时用的腾讯云优惠到期了，续费要每个月60多块钱，有点肉疼。因而买了一块树莓派，想要研究一下怎么将他搞成一个服务器。拖拉了几个月，最近总算是搞好了。本文将介绍一下我的搭建过程。</p>
<!-- more -->
<h2 id="物料准备">物料准备</h2>
<blockquote>
<ul>
<li>服务器一台。我使用树莓派当服务器。对于性能有需求的，可以考虑使用电脑主机或者买台物理服务器。注意平衡好功耗与性能的关系，毕竟一台电脑主机或物理机24小时开机，耗电量也不小。</li>
<li>智能路由器一台。我家用的斐讯K2，刷了潘多拉系统。智能路由器意味着系统是基于OpenWrt的，可以安装各种软件。</li>
<li>互联网。这里单独列出来，是因为对互联网也有要求。网络需要有公网IP,最好开放了80端口。很多互联网服务提供商(ISP)给用户提供的都是经过NAT转发的内网地址，并且屏蔽了80端口。这种情况下，可以打电话到ISP客服要求给调成公网IP和开放80端口。当然实在调不了，可以使用内网穿透来解决公网IP的问题，但端口就无能为力了，访问的时候，只能配合端口来访问。</li>
</ul>
</blockquote>
<p>当然，服务器直连互联网也是可以的。这样的话，搭建过程更简便，缺点是网络利用率低。</p>
<h2 id="地址解析">地址解析</h2>
<p>尽管ISP分配给我们了公网IP，但很大程度上公网IP是随着每次拨号会不停变动(比如家里停电、重启路由器等都会重新拨号)，每次拿到的将是一个新的公网IP。我们知道，两个端通信的前提是知道对方的IP地址，IP地址变动的话，将不能通信。举个简单的例子:我和小明经常打电话，有一天小明把电话号换了，我打他原来的电话号，就可能无人接听或者被其他陌生人接到了，那在这个时候，我只能去他家跑一趟，问问他的新电话号，以后我俩就又能互相打电话了。域名就是他的家庭地址，IP就是电话号。我们可以根据域名通过DNS服务来获取IP。有人可能会疑惑，公网IP变动后，域名是怎么知道你的IP变动呢?</p>
<h3 id="ddns">DDNS</h3>
<p>DNS我们都知道是用来将域名解析成IP的。那DDNS是什么?DDNS（Dynamic Domain Name Server，动态域名服务）是将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务器程序负责提供DNS服务并实现动态域名解析。<br>
由上述概念可知，只要我们在路由器每次联网时，监控IP地址变动，就有办法更新DNS解析记录。那怎么完成监控和更新?</p>
<h3 id="阿里ddns">阿里DDNS</h3>
<p>提供类似服务的厂商有很多，国内做的最好的还是阿里。相关文档点击<a href="https://help.aliyun.com/document_detail/141482.html">这里</a>..里面参考代码给的是Java版本的。其他实现可以在GitHub上搜一下。个人觉得最好还是选择bash实现，使用Cron定时任务定时执行就行。</p>
<p><strong>注意</strong>:有些智能路由器里本身就带有这个功能，无论是固件集成还是插件形式的。</p>
<p>如图所示，我家路由器固件集成了阿里DDNS<br>
<img src="https://aiyou.life/post-images/1574309892496.png" alt="" loading="lazy"></p>
<h3 id="域名">域名</h3>
<p>对域名其实没有什么要求，阿里云上随便买一个就行了。很便宜，10年只要60多块。<br>
如图所示<br>
<img src="https://aiyou.life/post-images/1574311032422.png" alt="" loading="lazy"><br>
记录前四条，是指向GitHubPage，也就是本博客的地址。阿里DDNS配置正确的话，会自动生成最后一条记录，地址指向了我家的路由器。</p>
<h3 id="内网穿透">内网穿透</h3>
<p>上面介绍的前提是你有公网IP的情况下。没有公网IP只能靠内网穿透来提供Web服务。相关教程可以Google查看。<br>
内网穿透优点是不需要公网IP，缺点是依赖服务提供商的稳定性，且不能自定义域名。如果人家服务器挂了，或者域名到期了，你这里也不能用了。</p>
<p><strong>注意</strong>: 有些智能路由器里本身就带有这个功能，无论是固件集成还是插件形式的。</p>
<p>如图所示，我家路由器固件集成了内网穿透工具<br>
<img src="https://aiyou.life/post-images/1574312158496.png" alt="" loading="lazy"></p>
<h3 id="验证">验证</h3>
<p>地址解析配置完成之后，需要验证一下是否解析成功</p>
<pre><code class="language-bash">ping -c 4 www.aiyou.life
</code></pre>
<p>查看解析到的IP是否与公网IP一致</p>
<p>如图所示<br>
<img src="https://aiyou.life/post-images/1574312401056.png" alt="" loading="lazy"></p>
<h2 id="端口转发">端口转发</h2>
<p>地址解析配置完成后，所有通过域名的访问都将直接请求到了路由器上。所以需要通过端口转发，将请求转到内网中的服务器上。这一步其实很简单，只需要记住几个常用的端口，配置一下就行了。</p>
<p>如图所示，来自互联网的80端口请求，都会转发到我的树莓派服务器(192.168.111)上。<br>
<img src="https://aiyou.life/post-images/1574313048391.png" alt="" loading="lazy"></p>
<p>这一步验证也很容易，在服务器上装个Nginx即可。然后通过域名访问，查看是否转发到了Nginx页面。</p>
<p>如图所示，即为成功（Chrome和Safari都把www给隐藏了，实际完整地址是 www.aiyou.life）<br>
<img src="https://aiyou.life/post-images/1574313486613.png" alt="" loading="lazy"></p>
<h2 id="应用转发">应用转发</h2>
<p>当只有一个静态应用时，只需要替换一下Nginx默认的文件就可以了。但我们的服务器肯定不止部署一个应用，且也不一定是静态的。因而需要考虑使用Nginx进行正向/反向代理。阿里DDNS理论上应该是支持多域名指向同一个IP地址的。这样的话，我可以为每一个应用分配一个二级域名，Nginx代理配置不同的server_name即可。但我尝试了半天也没有试成功。所以只能根据访问路径，代理到不同的应用。</p>
<p>配置代理时需要仔细查阅Nginx文档<br>
如图所示，昨天被这两个 / 坑了一天时间😭<br>
<img src="https://aiyou.life/post-images/1574314812013.png" alt="" loading="lazy"></p>
<p>转发到其他应用时，只需要再添加一个 location 即可。</p>
<h2 id="结语">结语</h2>
<p>现代智能家用路由器大都基于OpenWrt系统，而OpenWrt是基于Linux专为路由器打造的系统。路由器作为家庭网络中枢，其实功能是很骚的，可玩性很强。虽然路由器配置不高，但乐趣不就是在有限的资源中搞出不同的花样吗?</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于提高setTimeout与setInterval精确度的探索]]></title>
        <id>https://aiyou.life/post/kokne79MF/</id>
        <link href="https://aiyou.life/post/kokne79MF/">
        </link>
        <updated>2019-11-10T09:54:20.000Z</updated>
        <summary type="html"><![CDATA[<p>我们都知道，setTimeout与setInterval都不是精确的计时器，它还与当前主线程任务队列中的任务大小数量有关。当主线程任务队列的任务没有执行完毕时,setTimeout与setInterval就不会准确的在 t 时间后运行。那怎么才能提高二者的精确度呢?</p>
]]></summary>
        <content type="html"><![CDATA[<p>我们都知道，setTimeout与setInterval都不是精确的计时器，它还与当前主线程任务队列中的任务大小数量有关。当主线程任务队列的任务没有执行完毕时,setTimeout与setInterval就不会准确的在 t 时间后运行。那怎么才能提高二者的精确度呢?</p>
<!-- more -->
<h2 id="1-settimeoutsetinterval用法">1. setTimeout/setInterval用法</h2>
<p>这里还是简单提一嘴吧。这两个函数是定时器函数，setTimeout表示回调函数在 t 时间后运行，setInterval表示回调函数每隔 t 时间运行。</p>
<pre><code class="language-javascript">setTimeout(function(){
    ...
}, t)

setInterval(function(){
    ...
}, t)
</code></pre>
<div style="text-align:center;font-size:80%">代码 1.1</div>
<p>在 CSS3/HTML5之前，二者常用来绘制页面动画。CSS3/HTML5之后，常用css来绘制动画。另外还一个API是requestAnimationFrame. 该函数与setInterval类似，区别在于该函数没有 t 参数，默认是屏幕刷新的每帧调用一次。每秒调用（1/屏幕刷新率）次</p>
<pre><code class="language-javascript">requestAnimationFrame(function(){
    // DOM动画
})
</code></pre>
<div style="text-align:center;font-size:80%">代码 1.2</div>
<h2 id="2-发现问题">2. 发现问题</h2>
<p>Js是一个单线程语言，同一时间只能做同一件事情。这很好理解，如果同一时间能做多个任务，那么多任务都在操作DOM时，页面该怎么显示呢?因而JS设计为了单线程,但单线程也带来了一些问题，比如线程阻塞，CPU利用率不高等问题。看代码2.1</p>
<pre><code class="language-javascript">setTimeout(function () {
    console.log('task finished after ' + (Date.now() - startTime) + 'ms')
}, 0)

for (let i = 0 ; i &lt; 9000 ; i++) {
    console.log(5 + 8 + 8 + 8)
}
console.log('主线程复杂任务耗时:' + (Date.now() - startTime) + 'ms')
</code></pre>
<div style="text-align:center;font-size:80%">代码 2.1</div>
<p>执行结果如图 2.1 所示<br>
<img src="https://aiyou.life/post-images/1573436890372.png" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">图 2.1</div>
<p>for循环是一个耗时任务,阻塞了setTimeout的执行。我们设定0秒后执行输出，可实际结果是在1243ms之后输出，所以setTimeout的 t 参数定时不够精确。</p>
<!-- **结论**: *主线程里实际上是没有办法精确按时执行setTimeout/setInterval的回调函数。当浏览器js引擎解析代码遇到 setTimeout/setInterval 时，会将他们注册到下一个宏任务队列，只有执行完当前宏任务队列和微任务队列中的任务后，才会执行下一个宏任务队列中的任务。代码的执行本身就消耗时间*。 -->
<p>关于事件循环、宏任务、微任务不是本文重点，感兴趣的可以看看这篇文章<a href="https://juejin.im/post/5bac87b6f265da0a906f78d8">笔试题——JavaScript事件循环机制（event loop、macrotask、microtask）</a></p>
<p>那么到底要怎么解决精确度问题呢?</p>
<h2 id="3-解决问题">3. 解决问题</h2>
<p>前文我们一直在提及主线程主线程的，那么有没有办法利用其它线程进行计时呢?当代码执行到特定位置，通知其它线程中开始计时任务，主线程继续完成复杂任务，那么就不会阻塞计时器的运行，这样的话计时精确度就提高了。那么问题来了，JS不是一门单线程语言吗，怎么能利用除了主线程之外的其他线程呢?</p>
<p>在HTML5中，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker">Worker</a>的引入使得我们有了利用其它线程的能力。注意:<strong>Worker中不能操作DOM</strong>。</p>
<p>事情好办了。洋洋洒洒写下如下代码:</p>
<pre><code class="language-javascript">// worker生成器
const createWorker = (fn, options) =&gt; {
    const blob = new Blob(['(' + fn.toString() + ')()']);
    const url = URL.createObjectURL(blob);
    if (options) {
        return new Worker(url, options);
    }
    return new Worker(url);
} 
// 生成worker
const worker = createWorker(function () {
    onmessage = function(e) {
        console.log('进入WebWorker')
        let count = 1
        let startTime = Date.now()
        let timer = setInterval(function () {
            if (count++ === e.data) {
                clearInterval(timer)
                postMessage(startTime)
            }
        }, 1000)
    }
})

// 将代码2.1中的setTimeout替换为了 worker
// worker线程任务
const startTime = Date.now()
worker.postMessage(10)
worker.onmessage = function (e) {
    console.log('Worker线程任务内部耗时:' + (Date.now() - e.data) + 'ms')
    console.log('Worker线程任务耗时:'+ (Date.now() - startTime) + 'ms')
    this.terminate()
}
// 主线程任务
for (let i = 0 ; i &lt; 5000 ; i++) {
    console.log(5 + 8 + 8 + 8)
} 
console.log('主线程复杂任务耗时:' + (Date.now() - startTime) + 'ms')
</code></pre>
<div style="text-align:center;font-size:80%">代码 3.1</div>
<p>代码中, worker 线程每秒运行一次回调函数，进行计数，当回调函数执行了 10 次时，通知主线程。主线程打印 worker 线程运行时间。</p>
<p>代码运行结果如图3.1所示<br>
<img src="https://aiyou.life/post-images/1573401585223.png" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">图 3.1</div>
<p>运行结果并不符合预期。预期结果应当是<strong>Worker线程任务内部耗时</strong>与<strong>Worker线程任务耗时</strong>相差不多。出现这个结果的原因在于js代码在执行到<code>worker.postMessage(10)</code>时,并没有通知到Worker开始工作，而是等待当前任务队列执行完毕，才开始调用 Worker😭..这里不像fetch函数那样，代码执行到fetch时,浏览器另开线程去处理请求，拿到结果再进行回调,其他代码接着运行。</p>
<p>那么问题又来了,worker是属于宏任务还是微任务呢?<br>
验证代码如下:</p>
<pre><code class="language-javascript">...
setTimeout(()=&gt;{
    console.log('SetTimeout')
}, 0)
const worker = createWorker(function () {
    onmessage = function(e) {
    console.log('进入WebWorker ')
    let count = 1
    let startTime = Date.now()
    let timer = setInterval(function () {
            if (count++ === e.data) {
                clearInterval(timer)
                postMessage(startTime)
            }
        }, 1000)
    }
})
...
</code></pre>
<div style="text-align:center;font-size:80%">代码 3.2</div>
<p>运行结果如下:<br>
<img src="https://aiyou.life/post-images/1573403893208.png" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">图 3.2</div>
<p><code>SetTimeout</code>在<code>进入WebWorker</code>之前输出,说明<strong>Worker是宏任务</strong></p>
<h2 id="4-更进一步">4. 更进一步</h2>
<p>上一节中,我们考虑将计时器函数丢到Worker中去执行.但实际运行结果并不符合预期。那我们换一种思路，将主线程耗时任务丢到Worker执行，计时器精度会提高吗?答案是肯定的<br>
看如下代码4.1:</p>
<pre><code class="language-javascript">const startTime = Date.now()
setTimeout(function () {
    console.log('task finished after ' + (Date.now() - startTime) + 'ms')
}, 0)
// 将代码2.1中的耗时任务放到worker
const createWorker = (fn, options) =&gt; {
    const blob = new Blob(['(' + fn.toString() + ')()']);
    const url = URL.createObjectURL(blob);
    if (options) {
        return new Worker(url, options);
    }
    return new Worker(url);
}
const worker = createWorker(function () {
    const startTime = Date.now()
    for (let i = 0; i &lt; 9000; i++) {
        console.log(5 + 8 + 8 + 8)
        if (i === 9000 - 1) {
            postMessage(startTime)
        }
    }
})
worker.postMessage('start')
worker.onmessage = function (e) {
    console.log('Worker线程任务内部耗时:' + (Date.now() - e.data) + 'ms')
    console.log('Worker线程任务耗时:'+ (Date.now() - startTime) + 'ms')
    this.terminate()
}
</code></pre>
<div style="text-align:center;font-size:80%">代码 4.1</div>
<p>运行结果如图4.1:<br>
<img src="https://aiyou.life/post-images/1573437200815.png" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">图 4.1</div>
<p>对比上文代码2.1,可以看到计时器精度提高了不少。</p>
<p>将Worker替换成setTimeout试试</p>
<pre><code class="language-javascript">const startTime = Date.now()
setTimeout(function () {
    console.log('task finished after ' + (Date.now() - startTime) + 'ms')
}, 0)
// 将代码2.1中耗时任务放到setTimeout中
setTimeout(function () {
    for (let i = 0 ; i &lt; 9000 ; i++) {
        console.log(5 + 8 + 8 + 8)
    }
    console.log('主线程复杂任务耗时:' + (Date.now() - startTime) + 'ms')
}, 0)
</code></pre>
<div style="text-align:center;font-size:80%">代码 4.2</div>
<p>运行结果如图4.2:<br>
<img src="https://aiyou.life/post-images/1573808921223.png" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">图 4.2</div>
<p>对比上文代码2.1,可以看到计时器精度也提高了不少。</p>
<p><strong>总结</strong>:<em>主线程遇到耗时任务，应当考虑将其丢到下一个宏任务中去执行，这样不会阻塞当前任务队列的执行。题目中讲到要提高计时器函数精度，实际计时器也是一个宏任务。计时器与耗时任务在丢到下一个任务队列，要保证计时器任务在前，这样就可以提高计时器精度。再者，计时器函数要尽量靠前，先于其他代码执行，因为代码执行本身也会消耗时间</em>。</p>
<h2 id="5-最佳实战">5. 最佳实战</h2>
<p>主线程遇到无关DOM的耗时任务时，应当首先考虑使用Worker进行处理与计算。这样才不会阻塞主线程。代码4.2中，我们尝试将耗时任务放到主线程的中的下一个宏任务队列中，如果任务有上万数据进行计算，还是会阻塞主线程。Worker虽然属于宏任务，但只是将数据传输到Worker线程，由Worker进行计算。计算完成后，通知主线程。</p>
<h2 id="6-实现一个相对精确的setinterval">6. 实现一个相对精确的setInterval</h2>
<pre><code class="language-javascript">function loop(fn, interval) {
    const startTime = Date.now()
    let count = 0
    let currentInterval = interval
    let timer = 0
    function inner() {
        count++
        let offset = new Date().getTime() - (startTime + count * interval)
        currentInterval = interval - offset
        console.log('代码执行时间：' + offset, '下次循环间隔' + currentInterval)
        timer = setTimeout(inner, currentInterval)
        fn(timer)
    }
    setTimeout(inner, currentInterval)
}

let count = 0
loop(function (timer) {
    console.log('外部函数')
    if (count++ === 10) {
        console.log('外部函数执行完毕')
        clearTimeout(timer)
    }
}, 1000)
</code></pre>
<p>如上代码,我们构造了一个与<code>setInterval</code>函数功能类似的loop函数。插入主线程的任务的时间排除了代码的执行时间,相对于setInterval精度提高了很多。但当代码的执行时间大于设定的t时,主线程插入任务时间也不会准。</p>
<h2 id="7-后记">7. 后记</h2>
<p>这个问题来自于公众号上看到的某大厂的面试题。因而引发了一系列思考与探讨，顺便研究了一下WebWorker。其实提高setTimeout与setInterval计时精确度本身是一件无意义的事情，实际中本就没有这样的应用场景，但探索的过程还是蛮有意义的(就是有点耗费头发😭)。。</p>
]]></content>
    </entry>
</feed>