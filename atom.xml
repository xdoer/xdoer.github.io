<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aiyou.life</id>
    <title>文享日志</title>
    <updated>2020-09-05T04:40:38.462Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aiyou.life"/>
    <link rel="self" href="https://aiyou.life/atom.xml"/>
    <logo>https://aiyou.life/images/avatar.png</logo>
    <icon>https://aiyou.life/favicon.ico</icon>
    <rights>All rights reserved 2020, 文享日志</rights>
    <entry>
        <title type="html"><![CDATA[TS学习笔记]]></title>
        <id>https://aiyou.life/post/-d73T0KeE/</id>
        <link href="https://aiyou.life/post/-d73T0KeE/">
        </link>
        <updated>2020-09-05T04:08:59.000Z</updated>
        <summary type="html"><![CDATA[<p>很早之前写的一系列关于TypeScript的学习笔记，保存在了 Github 仓库。不是很方便查看，现迁移到Blog了</p>
]]></summary>
        <content type="html"><![CDATA[<p>很早之前写的一系列关于TypeScript的学习笔记，保存在了 Github 仓库。不是很方便查看，现迁移到Blog了</p>
<!-- more -->
<h2 id="基础类型">基础类型</h2>
<h3 id="字符串数字布尔值">字符串/数字/布尔值</h3>
<p>只需要在申明后面加 <strong>:type</strong> 即可</p>
<pre><code class="language-typescript">let str: string = '12345'

let num: number = 12345

let bool: boolean = true

</code></pre>
<h3 id="数组">数组</h3>
<p>要求数组中每一项的类别都相同</p>
<pre><code class="language-typescript">let ary: number[] = [1, 2, 3]

let ary: Array&lt;number&gt; = [1, 2, 3]
</code></pre>
<h3 id="元组">元组</h3>
<p>数组申明要求数组中每一项都相同，元组可为数组项申明不同类型</p>
<pre><code class="language-typescript">let tuple: [string, number]

tuple = ['123', 123]

tuple[2] = 234 // 正确

tuple[1] = '234' // 正确

tuple[3] = true // 错误

</code></pre>
<p>可以为没有申明的类型的数组项进行赋值，但是 <strong>赋值类型必须是申明列表中存在的类型</strong></p>
<h3 id="枚举">枚举</h3>
<p>枚举类型是 TypeScript 对 JavaScript 的扩展.</p>
<pre><code class="language-typescript">enum Color { Red = 1, Green, Blue }

let c: Color = Color.Green  // 2

let d: string = Color[2]  // 'Green'

</code></pre>
<p>默认从下标0开始编号，但是可以手动指定.</p>
<p>作用就是根据下标找值，或者根据值找下标。</p>
<h3 id="any">Any</h3>
<p>未知或者可变的变量类型由Any进行声明</p>
<pre><code class="language-typescript">let ha: any = 4

ha = '44'  // 正确

ha = true  // 正确

ha = [] // 正确

let list: any[] = [1, true, &quot;free&quot;] // 正确
</code></pre>
<p>遇到any标记的变量，编译器会跳过类型检查，所以只要在 JavaScript 中声明没问题就行</p>
<h3 id="void">Void</h3>
<p>声明为 void 类型说明该变量没有任何值，只能赋予 undefined 或者 null，这种操作没什么用</p>
<p>当函数没有返回值时，需要声明函数返回为 void</p>
<pre><code class="language-typescript">let hh: void = undefined

function warnUser(): void {
  console.log(&quot;This is my warning message&quot;);
}

</code></pre>
<h3 id="null-undefined">Null / Undefined</h3>
<p>Null / Undefined 是两个类型，申明之后只能赋值本身。。但这样做没什么用...</p>
<p>默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。</p>
<h3 id="never">Never</h3>
<p>表示永远不存在值的类型</p>
<pre><code class="language-typescript">// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
  throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
  return error(&quot;Something failed&quot;);
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
  while (true) {
  }
}
</code></pre>
<p>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。</p>
<h3 id="object">Object</h3>
<p>除number，string，boolean，symbol，null或undefined之外的类型。</p>
<h2 id="变量申明">变量申明</h2>
<p>变量申明没什么特别的，就是ES6中的知识，let,const...</p>
<p>研究一下下面这个</p>
<p>示例代码</p>
<pre><code class="language-typescript">function f([first, second]: [number, number]) {
    console.log(first);
    console.log(second);
}

const input = [1, 2]

f(input); // 报错

</code></pre>
<p>这是 TypeScript 中文网的示例代码。。结果居然报错了。。研究了一下明白了为什么。</p>
<p>首先 typescript 环境下，像 <code>const input = [1, 2]</code> 这样的定义，数组项都为数字，默认申明为<code>Array&lt;number&gt;</code>.所以相当于<code>const input: Array&lt;number&gt; = [1, 2]</code></p>
<p>看函数参数 <code>[first, second]</code> , 调用函数 <code>f(input)</code>, 这里用到了变量解构，<code>input</code>是一个申明为所有元素都为 number 的 <strong>数组</strong>。再看参数后面的类型定义，这是用 <strong>元组</strong> 形式申明传入参数的类型。。传入的参数与参数申明类型不符，所以报错。</p>
<p>正确代码</p>
<pre><code class="language-typescript">function f([first, second]: Array&lt;number&gt;) {
    console.log(first);
    console.log(second);
}

const input = [1, 2]  // 或者 const input: Array&lt;number&gt; = [1, 2]

f(input); // 正确

</code></pre>
<p>或者</p>
<pre><code class="language-typescript">function f([first, second]: [number, number]) {
    console.log(first);
    console.log(second);
}

const input: [number, number] = [1, 2]

f(input); // 正确

</code></pre>
<h3 id="对象解构">对象解构</h3>
<h4 id="属性值重命名">属性值重命名</h4>
<p>示例代码:</p>
<pre><code class="language-typescript">const { name: myName }: { name: string, age: number } = { name: 'han', age: 12 }
</code></pre>
<p>这里很乱，逐一分析一下:</p>
<p>首先不含类型检查的最基本的对象变量解构是这样的(ES6语法)</p>
<pre><code class="language-typescript">const { name } = { name: 'han', age: 12 }

// 上面这一行相当于
const { name: name } = { name: 'han', age: 12 }
</code></pre>
<p>如果要对name值重命名，则需要在 name 后加 :</p>
<pre><code class="language-typescript">const { name: myName } = { name: 'han', age: 12 }
</code></pre>
<p>TypeScript 在ES6基础上，添加了类型检查，也就是上面的示例代码。</p>
<p>类型检查不能只检查自己需要的数据，而是检查所有要解构的对象，所以<code>age: number</code>这里必不可少</p>
<p><strong>在使用对象解构前，一定要牢记ES6的解构语法，在此基础上，再使用 TypeScript 的类型限制</strong></p>
<h4 id="展开操作符">展开操作符</h4>
<p>使用与ES6一致</p>
<p>看个小例子</p>
<pre><code class="language-typescript">class C {
  p = 12;
  m() {
  }
}

let c = new C();
let clone = { ...c };
clone.p;  // ok
clone.m();  // error
</code></pre>
<p>当展开操作符展开一个对象时，会丢失方法。展开操作符展开的是可枚举属性。</p>
<h2 id="接口">接口</h2>
<p>原文给出两段代码</p>
<pre><code class="language-typescript">function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label);
}

let myObj = { size: 10, label: &quot;Size 10 Object&quot; };

printLabel(myObj);

</code></pre>
<p>接口版本的</p>
<pre><code class="language-typescript">interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

let myObj = {size: 10, label: &quot;Size 10 Object&quot;};
printLabel(myObj);

</code></pre>
<p>首先这里有疑问，在上面那种方式可以实现类型检查的情况下，为什么要推出接口这个新概念?先接着往下看</p>
<h3 id="可选属性">可选属性</h3>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: &quot;white&quot;, area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

let mySquare = createSquare({color: &quot;black&quot;});  // ok

let mySquare = createSquare({});  // ok

let mySquare = createSquare();  // error

</code></pre>
<p>首先看调用这里，传参空对象是可以的，因为接口规定了我们 color, width 可传可不传。。但是没告诉我们参数是可选的，所以不传参会报错。。</p>
<p>改造成如下代码</p>
<pre><code class="language-typescript">function createSquare(config: SquareConfig = {}): {color: string; area: number} { 
  ...
}

let mySquare = createSquare();  // ok

</code></pre>
<p>初次看这个函数是有点懵逼的。<code>function createSquare(config: SquareConfig): {color: string; area: number}</code>中的<code>: {color: string; area: number}</code>是什么观察了半天？各种测试之后，才想起，这是规定返回值的类型的...这种函数多练练多写写就好了</p>
<p>再来看我们第一部分给出的问题，为什么要推出接口这个概念，这里还不好说，但是可以不用接口的方式实现上面的函数</p>
<pre><code class="language-typescript">function createSquare(config: {color?: string, width?: number} = {}): {color: string; area: number} { 
  ...
}

let mySquare = createSquare({color: &quot;red&quot;});  // ok

let mySquare = createSquare({});  // ok

let mySquare = createSquare();  // ok

</code></pre>
<h3 id="只读属性">只读属性</h3>
<pre><code class="language-typescript">interface Point {
  readonly x: number;
  readonly y: number;
}

let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!
</code></pre>
<p>只读属性只能在对象创建的时候给出初始值，后续就没办法进行修改。</p>
<p>我们接着改造上面的函数</p>
<pre><code class="language-typescript">interface SquareConfig {
  readonly color?: string;
  readonly width?: number;
}

function createSquare(config: SquareConfig = {}): { color: string; area: number } {
  let newSquare = { color: &quot;white&quot;, area: 100 };
  if (config.color) {
    config.color = &quot;red&quot;  // error
    newSquare.color = config.color
  }
  if (config.width) {
    config.width = 200  // error
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}
</code></pre>
<p>我们将接口中的 color 和 width 都配置成 只读 。所以当在函数体中进行修改参数时会报错。</p>
<p>那我们怎么使用无接口的方法达到同样的效果(配置属性不可修改)?</p>
<p>我们知道原生JS中，每个属性都包含了一个描述符，描述符中有四个配置项，可配置属性行为</p>
<blockquote>
<ul>
<li>configurable: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li>
<li>enumerable: 表示能否通过for-in循环返回属性。</li>
<li>writable: 表示能否修改属性的值。</li>
<li>value: 包含这个属性的数据值。</li>
</ul>
</blockquote>
<p>我们利用其中的 <strong>writable</strong> 是否可以实现呢?</p>
<p>看下面的代码</p>
<pre><code class="language-typescript">function createSquare(config: {color?:string,width?:number} = {}): { color: string; area: number } {
  let newSquare = { color: &quot;white&quot;, area: 100 };

  Object.defineProperty(config, &quot;color&quot;, { writable: false})
  Object.defineProperty(config, &quot;width&quot;, { writable: false })
  
  if (config.color) {
    config.color = &quot;red&quot;
    newSquare.color = config.color
  }
  if (config.width) {
    config.width = 200
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

createSquare({ color: &quot;black&quot; }); // error

createSquare({})  // ok

createSquare()  // ok
</code></pre>
<p>代码可正确通过TypeScript的编译，但是在JavaScript代码运行时会出错。(TypeScript在编译时期检查错误，检查的是语法错误。我们写的代码没有语法错误，所以可以通过编译)</p>
<p>可以看到，虽然这里实现了与接口基本相同的效果，但是编译阶段没办法捕捉到错误。</p>
<p>此外还有只读类型数组</p>
<pre><code class="language-typescript">let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray&lt;number&gt; = a;

a.push(1) // ok
ro.push(2)  // error

let b = ro as Array&lt;number&gt;

b.push(1) // ok
</code></pre>
<p>数组设置成只读的之后，将不能再使用原来操作数组的各种方法。但是进行类型断言(类型断言是一种强制转化的机制，TypeScript认为人比程序更了解这个变量是什么类型)之后就又可以了</p>
<h3 id="额外的类型检查">额外的类型检查</h3>
<p>还以上面的代码为例</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  ...
}

let mySquare = createSquare({ height: 22 });  // 报错

</code></pre>
<p><s>向函数中传入了接口规定的属性以外的属性，会报错。这其实很好理解是为什么，没有经过类型检查等手段就将一些变量带入函数的运行环境中，那要 TypeScript 有什么用呢? TypeScript 最大的优点就是将所有变量可以掌控，哪一个阶段数据是什么状态都是明明白白的。</s></p>
<p>那怎么解决上面的这个问题 ?</p>
<p>可以使用类型断言，将我们传入的参数断言成接口类型的数据</p>
<pre><code class="language-typescript">let mySquare = createSquare({ height: 22 } as SquareConfig);  
</code></pre>
<p><strong>这里注意为什么将{ height: 22} 转化成 SquareConfig 类型之后就能用了，明明 SquareConfig 中并不存在 height 属性。这是因为类型断言不进行特殊的数据检查和解构</strong></p>
<p>原文中还给出了&quot;字符串索引签名&quot;这种方式</p>
<pre><code class="language-typescript">interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}
</code></pre>
<p>表示SquareConfig可以有任意数量的属性，并且只要它们不是 color 和 width，那么就无所谓它们的类型是什么</p>
<p>&quot;字符串索引签名&quot;这里先放着，之后再学习</p>
<p>最后也是最不推荐的一种是绕过检查</p>
<pre><code class="language-typescript">createSquare({ colour: &quot;red&quot;, width: 100 });  // 报错

let squareOptions = { colour: &quot;red&quot;, width: 100 };
let mySquare = createSquare(squareOptions);   // 正确
</code></pre>
<p>这里为什么能绕过检查????原文解释是这样的<strong>因为 squareOptions不会经过额外属性检查，所以编译器不会报错</strong>.这里保留疑问..</p>
<p>请教了大神之后明白了 <a href="part-3(1)-add.md">TypeScript绕过编译器检查的一点困惑</a></p>
<h3 id="函数类型">函数类型</h3>
<pre><code class="language-typescript">interface SearchFunc {
  (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source, subString) {
  let result = source.search(subString);
  return result &gt; -1;
}

// 代码相当于
let mySearch: (source: string, subString: string) =&gt; boolean = function (source, subString) : boolean {
  let result = source.search(subString);
  return result &gt; -1;
}

// (source: string, subString: string) =&gt; boolean 也是规范函数写法的一种形式
</code></pre>
<p>mySearch函数 是 SearchFunc 类型的，SearchFunc 接口中定义了必须要传入的参数及参数类别，以及返回值的类别。那示例中函数定义中的参数类型指定显得有些多余了，去掉也是没错的</p>
<pre><code class="language-typescript">mySearch = function(source, subString) {
  ...
}
</code></pre>
<p>另外定义函数的函数参数名称是可以改变的,函数的参数会逐个进行检查,位置对了就行</p>
<pre><code class="language-typescript">mySearch = function(sur, sub) {
  ...
}
</code></pre>
<p>那这里传入一个需要变量解构的对象，接口该怎么定义?</p>
<p>如下</p>
<pre><code class="language-typescript">function test({ sid }) {
  ...
}

test({ sid: '123', num: 123 })
</code></pre>
<p>定义如下:</p>
<pre><code class="language-typescript">interface Sid {
  sid: string,
  [propName: string]: any;
}

interface Test {
  (sid: Sid, num: number): number
}

const test: Test = function ({ sid }, num) {
  return Number.parseInt(sid) + num
}

test({ sid: '123', ha: '234' }, 2)
</code></pre>
<h3 id="可索引的类型">可索引的类型</h3>
<pre><code class="language-typescript">interface StringArray {
  [index: number]: string;
}

let myArray: StringArray;
myArray = [&quot;Bob&quot;, &quot;Fred&quot;];

let myStr: string = myArray[0];
</code></pre>
<p>表示了当用 number 去索引 StringArray 时会得到 string 类型的返回值。这就相当于一个字符串数组</p>
<p>这种东西定义成一个数组不就完了?为什么要弄出这种东西?</p>
<h3 id="类类型">类类型</h3>
<h4 id="实现接口">实现接口</h4>
<p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约</p>
<pre><code class="language-typescript">interface ClockInterface {
  currentTime: Date;
  setTime(d: Date): void;
}

class Clock implements ClockInterface {
  currentTime: Date;
  constructor() {
    this.currentTime = new Date()
  }
  setTime(d: Date) {
    this.currentTime = d;
  }
}
</code></pre>
<p><s>接口中描述的数据和方法挂载到原型上</s></p>
<p>接口中定义的属性将在类中属性上定义。定义的方法将挂载到原型上。</p>
<h4 id="类静态部分与实例部分的区别">类静态部分与实例部分的区别</h4>
<pre><code class="language-typescript">// 函数接口
interface ClockConstructor {
    // 定义了一个构造函数，返回 ClockInterface 类型数据
    new (hour: number, minute: number): ClockInterface;
}

// 类接口
interface ClockInterface {
    // 定义了一个继承类需要实现的函数。
    tick():void;
}

// 参数 ctor 为构造函数
function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}

// 继承类需要实现 tick 函数
class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;beep beep&quot;);
    }
}
class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;tick tock&quot;);
    }
}

let digital = createClock(DigitalClock, 12, 17);
let analog = createClock(AnalogClock, 7, 32);
</code></pre>
<p>两个类均继承自 ClockInterface , 所以他们应当实现接口中的 tick 函数。</p>
<p>观察函数 createClock</p>
<p>参数<code>ctor: ClockConstructor</code>相当于<code>const ctor : ClockConstructor = DigitalClock</code></p>
<p>于是再看 接口ClockConstructor，接口中表明，实现该接口的函数需要返回 ClockInterface 的一个实例</p>
<p>直接定义一个接口规范类中的静态部分和实例部分不好实现。代码中使用了两个接口实现分别规范这两个部分。</p>
<p>ClockInterface 接口直接规范了实例部分函数</p>
<p>ClockConstructor 接口规范了构造函数，规范了静态部分</p>
<h3 id="继承接口">继承接口</h3>
<p>看代码、很容易明白</p>
<pre><code class="language-typescript">interface Shape {
    color: string;
}

interface PenStroke {
    penWidth: number;
}

interface Square extends Shape, PenStroke {
    sideLength: number;
}

let square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
square.penWidth = 5.0;
</code></pre>
<h3 id="混合类型">混合类型</h3>
<p>看代码</p>
<pre><code class="language-typescript">interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = &lt;Counter&gt;function (start: number) { };
    // 相当于 let counter = function (start: number) { } as Counter;
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
</code></pre>
<p>接口中定义了三种类型，用在函数上，函数应当包含一个 number 参数，返回 string 类型数据，观察 getCounter 函数，函数内部定义了一个名为 counter 函数，函数被强转为 Counter 类型，所以可以挂载在 Counter 接口中定义的 reset 和 interval</p>
<h3 id="接口继承类">接口继承类</h3>
<p>看代码</p>
<pre><code class="language-typescript">class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class TextBox extends Control {
    select() { }
}

// 错误：“Image”类型缺少“state”属性。
class Image implements SelectableControl {
    select() { }
}

class Location {

}
</code></pre>
<p>原文说到&quot;接口继承类时，会继承其的 private 和 protected 成员&quot;。实际上将上面代码 Control 类中的 private 改为 public ,Image 类也会报错。</p>
<h2 id="类">类</h2>
<p>先看代码</p>
<pre><code class="language-typescript">class Animal {
    name: string;
    constructor(theName: string) { this.name = theName; }
    move(distanceInMeters: number = 0) {
        console.log(`${this.name} moved ${distanceInMeters}m.`);
    }
}

class Snake extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 5) {
        console.log(&quot;Slithering...&quot;);
        super.move(distanceInMeters);
    }
}

class Horse extends Animal {
    constructor(name: string) { super(name); }
    move(distanceInMeters = 45) {
        console.log(&quot;Galloping...&quot;);
        super.move(distanceInMeters);
    }
}

let sam = new Snake(&quot;Sammy the Python&quot;);
let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);

sam.move();
tom.move(34);
</code></pre>
<p>像是 Java 和 ES6 语法的混合。很好看懂</p>
<p>定义到 constructor 中的属性，需要在 class 的大括号内表明是什么类型的</p>
<h2 id="private-修饰符">private 修饰符</h2>
<p>私有属性修饰符。被修饰属性只能在当前类中被访问。</p>
<pre><code class="language-typescript">class Animal {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

class Rhino extends Animal {
    constructor() { super(&quot;Rhino&quot;); }
}

class Employee {
    private name: string;
    constructor(theName: string) { this.name = theName; }
}

let animal = new Animal(&quot;Goat&quot;);
let rhino = new Rhino();
let employee = new Employee(&quot;Bob&quot;);

animal = rhino;
animal = employee; // 错误: Animal 与 Employee 不兼容.
</code></pre>
<p>只有当 私有属性 来源于同一处时，才兼容</p>
<h2 id="protected-修饰符">protected 修饰符</h2>
<p>保护属性修饰符。被修饰属性除了能在当前类被访问，还可以被派生类访问</p>
<pre><code class="language-typescript">class Person {
    protected name: string;
    protected constructor(theName: string) { this.name = theName; }
}

// Employee 能够继承 Person
class Employee extends Person {
    private department: string;

    constructor(name: string, department: string) {
        super(name);
        this.department = department;
    }

    public getElevatorPitch() {
        return `Hello, my name is ${this.name} and I work in ${this.department}.`;
    }
}

let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);
let john = new Person(&quot;John&quot;); // 错误: 'Person' 的构造函数是被保护的.

</code></pre>
<h2 id="public-修饰符">public 修饰符</h2>
<p>在哪都能被访问到。没有修饰符时，默认为 public</p>
<h2 id="readonly-修饰符">readonly 修饰符</h2>
<p>数据只读。只读属性必须在声明时或构造函数里被初始化</p>
<h2 id="getset-存取器">get/set 存取器</h2>
<p>简单看个例子就好</p>
<pre><code class="language-typescript">let passcode = &quot;secret passcode&quot;;

class Employee {
    private _fullName: string;

    get fullName(): string {
        return this._fullName;
    }

    set fullName(newName: string) {
        if (passcode &amp;&amp; passcode == &quot;secret passcode&quot;) {
            this._fullName = newName;
        }
        else {
            console.log(&quot;Error: Unauthorized update of employee!&quot;);
        }
    }
}

let employee = new Employee();
employee.fullName = &quot;Bob Smith&quot;;
if (employee.fullName) {
    alert(employee.fullName);
}
</code></pre>
<h2 id="静态属性">静态属性</h2>
<p>静态属性存在于类本身上面而不是类的实例上。</p>
<pre><code class="language-typescript">class Grid {
    static origin = {x: 0, y: 0};
    calculateDistanceFromOrigin(point: {x: number; y: number;}) {
        let xDist = (point.x - Grid.origin.x);
        let yDist = (point.y - Grid.origin.y);
        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;
    }
    constructor (public scale: number) { }
}

let grid1 = new Grid(1.0);  // 1x scale
let grid2 = new Grid(5.0);  // 5x scale

console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));
console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));
</code></pre>
<p>改写成我们常见的 JavaScript 形式</p>
<pre><code class="language-javascript">function Grid (scale) {
  this.scale = scale
}

Grid.origin = { x:0, y:0} // 这个就是 TypeScript 中的静态属性

Grid.prototype.calculateDistanceFromOrigin = function (point) {
  ...
}

</code></pre>
<h2 id="抽象类">抽象类</h2>
<p>抽象类做为其它派生类的基类使用</p>
<pre><code class="language-typescript">abstract class Department {

    constructor(public name: string) {
    }

    printName(): void {
        console.log('Department name: ' + this.name);
    }

    abstract printMeeting(): void; // 必须在派生类中实现
}

class AccountingDepartment extends Department {

    constructor() {
        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()
    }

    printMeeting(): void {
        console.log('The Accounting Department meets each Monday at 10am.');
    }

    generateReports(): void {
        console.log('Generating accounting reports...');
    }
}

let department: Department; // 允许创建一个对抽象类型的引用
department = new Department(); // 错误: 不能创建一个抽象类的实例
department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值
department.printName();
department.printMeeting();
department.generateReports(); // 错误: 方法在声明的抽象类中不存在
</code></pre>
<p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现.相对于接口中定义的方法，抽象类定义抽相关方法，需要加 abstract 关键字。</p>
<p>接口与抽象类的区别:接口中的定义必须在其继承中进行实现，接口中本身不包含实现，只有定义。抽象类中的普通函数需要具体实现，抽象函数则在派生各类中进行实现。</p>
<h2 id="函数">函数</h2>
<pre><code class="language-typescript">let myAdd: (x: number, y: number) =&gt; number = function (x: number, y: number): number { return x + y; };
</code></pre>
<p>看教程中给出的这个实例，不是特别容易看懂</p>
<p>以等号为分界线。左边定义了一个变量 myAdd , 冒号后表明了类型:两个 number 参数和返回 number 类型数据</p>
<p><strong>在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</strong></p>
<p>完整的一个函数应当是上面这种定义，但可以省略部分</p>
<p>代码如下:</p>
<pre><code class="language-typescript">// 由右边可以推断左边
let myAdd = function(x: number, y: number): number { return x + y; };

// 由左边可以推断右边
let myAdd: (baseValue: number, increment: number) =&gt; number =
    function(x, y) { return x + y; };
</code></pre>
<h3 id="剩余参数">剩余参数</h3>
<pre><code class="language-typescript">function buildName(firstName: string, ...restOfName: string[]) {
  return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);
}

let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName;
</code></pre>
<p>注意与 ES6 区别在于需要规范 数组类型</p>
<h3 id="this">this</h3>
<p>直接调用 this 时注意 this 为 any 类型。需要手动指定一下 this 的类型</p>
<p>实例如下</p>
<pre><code class="language-typescript">interface Card {
    suit: string;
    card: number;
}
interface Deck {
    suits: string[];
    cards: number[];
    createCardPicker(this: Deck): () =&gt; Card;
}
let deck: Deck = {
    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],
    cards: Array(52),
    // NOTE: The function now explicitly specifies that its callee must be of type Deck
    createCardPicker: function(this: Deck) {
        return () =&gt; {
            let pickedCard = Math.floor(Math.random() * 52);
            let pickedSuit = Math.floor(pickedCard / 13);

            return {suit: this.suits[pickedSuit], card: pickedCard % 13};
        }
    }
}

let cardPicker = deck.createCardPicker();
let pickedCard = cardPicker();

alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit);
</code></pre>
<p>文档中说直接调用 this 会报错，但是我在实际测试中并没有发现这个问题...实例代码是处理 this 之后的代码。可以 看到手动指定了一波this是什么</p>
<h3 id="函数重载">函数重载</h3>
<p>传统的面向对象编程语言中，重载概念是:在函数名相同的情况下，根据参数个数、参数类型不同的情况下调用不同的函数。</p>
<p>但在 JavaScript 中，函数名相同的话，会取最后定义的函数。</p>
<p>TypeScript 中函数重载是 申明了相同函数名称，只是参数类型、个数、返回类型不同。具体函数实现还是只有一个。</p>
<pre><code class="language-typescript">let suits = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];

// 定义了两种函数
// {suit: string; card: number; }[] 表示数组每一项都是 包含 suit 和 card 的对象
function pickCard(x: {suit: string; card: number; }[]): number;

function pickCard(x: number): {suit: string; card: number; };

// 函数具体实现
function pickCard(x): any {

    if (typeof x == &quot;object&quot;) {
        let pickedCard = Math.floor(Math.random() * x.length);
        return pickedCard;
    }

    else if (typeof x == &quot;number&quot;) {
        let pickedSuit = Math.floor(x / 13);
        return { suit: suits[pickedSuit], card: x % 13 };
    }
}

let myDeck = [{ suit: &quot;diamonds&quot;, card: 2 }, { suit: &quot;spades&quot;, card: 10 }, { suit: &quot;hearts&quot;, card: 4 }];
let pickedCard1 = myDeck[pickCard(myDeck)];

alert(&quot;card: &quot; + pickedCard1.card + &quot; of &quot; + pickedCard1.suit);

let pickedCard2 = pickCard(15);
alert(&quot;card: &quot; + pickedCard2.card + &quot; of &quot; + pickedCard2.suit);
</code></pre>
<h2 id="泛型">泛型</h2>
<h3 id="泛型变量">泛型变量</h3>
<p>先看例子</p>
<pre><code class="language-typescript">function Test( ary: any ): any {
  return ary
}
</code></pre>
<p>这个函数隐藏了一些信息。我们传入一些参数，并不知道函数会返回哪些类型的数据。</p>
<p>泛型就是解决这个问题的</p>
<p>再看用泛型改写之后的例子</p>
<pre><code class="language-typescript">function Test&lt;T&gt; (ary: T): T {
  return ary
}
</code></pre>
<p>T不指代具体的类型，只表明类型一致。</p>
<p>函数调用示例</p>
<pre><code class="language-typescript">const t = Test&lt;string&gt;(&quot;abcd&quot;)

// 省略写法如下
const t2 = Test(&quot;abcd&quot;)
</code></pre>
<p>相较于 any, 利用泛型可以明确返回什么类型数据</p>
<p>加上 &lt;&gt; 之后，很容易和 类型断言 混了，所以平时用 类型断言 时，用 as 形式</p>
<h3 id="泛型接口">泛型接口</h3>
<pre><code class="language-typescript">// 代码1
interface GenericIdentityFn {
    &lt;T&gt;(arg: T): T;
}

function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn = identity;
myIdentity(2)

// 代码2
interface GenericIdentityFn&lt;T&gt; {
    (arg: T): T;
}

function identity&lt;T&gt;(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn&lt;number&gt; = identity;
myIdentity(2)
</code></pre>
<p>代码1 中可以根据传入的参数自动推断出 T 是什么类型的</p>
<p>代码2 相较于代码1 泛型参数当作整个接口的一个参数。在定义 myIdentity 时就指定 T 是什么类型，相对来说 代码2更清晰</p>
<h3 id="泛型类">泛型类</h3>
<p>原文给出的代码并不能正确运行，我添加了一些内容</p>
<pre><code class="language-typescript">const parm = '123'
class GenericNumber&lt;T&gt; {
  zeroValue: T;
  add: (x: T, y: T) =&gt; T;
  static n: T = &lt;T&gt;(parm)   // 报错
  constructor ( n: T) {
    this.zeroValue = n
    this.add = function (x, y) {
      return &lt;T&gt;(x)
    }
  }
}

let myGenericNumber = new GenericNumber&lt;number&gt;(1);
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function (x, y) { return x + y; };
</code></pre>
<p>其实到这里就可以看出，泛型其实就是统一类型用的。</p>
<p>泛型类指的是实例部分的类型，类的静态属性不能使用泛型类型</p>
<h3 id="泛型约束">泛型约束</h3>
<pre><code class="language-typescript">interface Lengthwise {
    length: number;
}

function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}
</code></pre>
<p>如代码所示。泛型约束规范传入的 T 类型具有什么样的特征。示例代码需要传入具有 length 属性的类型数据</p>
<h3 id="在泛型中使用类类型">在泛型中使用类类型</h3>
<p>看代码</p>
<pre><code class="language-typescript">class BeeKeeper {
    hasMask: boolean;
}

class ZooKeeper {
    nametag: string;
}

class Animal {
    numLegs: number;
}

class Bee extends Animal {
    keeper: BeeKeeper;
}

class Lion extends Animal {
    keeper: ZooKeeper;
}

function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A {
    return new c();
}

createInstance(Lion).keeper.nametag;  // typechecks!
createInstance(Bee).keeper.hasMask;   // typechecks!
</code></pre>
<p>首先代码定义了5个类，类中分别定义了属性(示例代码不完整，缺 constructor).</p>
<p>观察 Bee 和 Lion，可以发现两者均继承自 Animal 类，由此，二者均可以调用 Animal 类中的公有属性 numLegs。再看 Bee 中的  keep , 数据类型为 BeeKeeper, 由此 由Bee 创建的实例可以通过 keeper 来调用 BeeKeeper 中的数据。Lion同理</p>
<p>再看 createInstance 函数，使用泛型约束 传入的类型必须具有 Animal 类中的 numLegs 属性。因为 Bee 和 Lion 均继承自 Animal，所有都有这个属性。看函数参数c是一个 A类型的构造函数</p>
<h2 id="枚举-2">枚举</h2>
<p><a href="part-1.md">基础类型</a> 中简单介绍了枚举类型。</p>
<p>看代码</p>
<pre><code class="language-typescript">enum Color {
  Green,
  Blue,
  Red
}
</code></pre>
<p>使用 enum 关键字定义一个 枚举类型 数据结构。</p>
<p>使用示例:</p>
<pre><code class="language-typescript">const red: string = Color[2]

const color: number = Color.Red
</code></pre>
<p>如上的定义 Color 代码，默认使用 0,1,2...递增编号。也可以手动指定编号</p>
<p>如下</p>
<pre><code class="language-typescript">enum Color {
  Green= 2,
  Blue= 4,
  Red
}
</code></pre>
<p>原文代码中给出这样一个例子</p>
<pre><code class="language-typescript">enum Response {
  No = 0,
  Yes = 1,
}

function respond(recipient: string, message: Response): void {
  // ...
}

respond(&quot;Princess Caroline&quot;, Response.Yes)

</code></pre>
<p>尝试将函数参数中的 Response 改为 number, 结果还是正确的</p>
<pre><code class="language-typescript">const message: Response = 1
</code></pre>
<p>这就说明<strong>数字类型与枚举类型兼容</strong></p>
<h3 id="字符串枚举">字符串枚举</h3>
<p>上面是使用数字编号进行引索，实际还可以使用字符串枚举</p>
<pre><code class="language-typescript">enum Color {
  Green='This is green',
  Blue='This is blue',
  Red='this is red'
}
</code></pre>
<h3 id="计算的和常量成员">计算的和常量成员</h3>
<pre><code class="language-typescript">enum FileAccess {
    None,
    Read = 1 &lt;&lt; 1,
    Write = 1 &lt;&lt; 2,
    ReadWrite  = Read | Write,
    G = &quot;123&quot;.length
}
</code></pre>
<p><code>&lt;&lt;</code>是 js 中的位移运算符， <code>|</code> 是或运算符</p>
<h2 id="类型推论">类型推论</h2>
<h3 id="最佳通用类型">最佳通用类型</h3>
<p>看下面的例子</p>
<pre><code class="language-typescript">let x = [1, '2']  // 正确

x = [true, '3'] // 错误
</code></pre>
<p>定义时没有类型，编译器会自动推断 x 是什么类型。</p>
<p>代码中 x 被推断为 元组 <code>[number, string]</code>, 所以 x 赋值 <code>[true, '3']</code> 失败</p>
<p>再看这个</p>
<pre><code class="language-typescript">let zoo = [new Rhino(), new Elephant(), new Snake()];
</code></pre>
<p>会被推断为联合数组类型</p>
<p>相当于</p>
<pre><code class="language-typescript">let zoo:(Rhino, Elephant, Snake)[] = [new Rhino(), new Elephant(), new Snake()];
</code></pre>
<h2 id="类型兼容性">类型兼容性</h2>
<p>TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。</p>
<p>还是给一些实例代码自己看</p>
<pre><code class="language-typescript">// 案例1
interface Named {
    name: string;
}

class Person {
    name: string;
}

let p: Named;
p = new Person(); // 正确

// 案例2
interface Named {
    name: string;
}

let x: Named;
let y = { name: 'Alice', location: 'Seattle' };
x = y;

// 案例3
let x = (a: number) =&gt; 0;
let y = (b: number, s: string) =&gt; 0;

y = x; // 正确
x = y; // 错误

// 案例4
interface Named {
    name: string;
}

class Person {
    name: number;
}

let p: Named;
p = new Person(); // 错误

</code></pre>
<p>案例1 中 Named 接口与 Person 类具有相同的组成结构，所以允许赋值</p>
<p>案例2 中 <code>{ name: 'Alice', location: 'Seattle' }</code>中包含了 x 中需要的 name 属性，所以允许赋值</p>
<p>案例3 中 函数参数 比较二者对应位置的参数类型是否相同。</p>
<p>x 函数的参数类型都能在 y 函数中找到对应类型。所以可以兼容。这里注意与 案例2 的区别，案例2 是右边多，但桉树这里是左边多</p>
<p>案例4 中 虽然二者都有 name 属性，但类型不一致，所以不兼容</p>
<h3 id="枚举-3">枚举</h3>
<p>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的。</p>
<h3 id="类-2">类</h3>
<p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 <strong>比较两个类类型的对象时，只有实例的成员会被比较</strong>。 静态成员和构造函数不在比较的范围内。</p>
<p>实例部分是只有在创建对象时，才初始化的数据，静态部分就是将属性直接挂在到构造函数上(在 TypeScript 中静态部分使用关键字 static 标识)。</p>
<pre><code class="language-typescript">class Animal{
  name: string
  static age: number = 12
  constructor (n: string) {
    this.name = n
  }
  setName (name: string) {
    this.name = name
  }
}

class Person{
  name: string
  static aged: number = 100
  constructor(n: string, age?: number ) {
    this.name = n
  }
  setName (name: string) {
    this.name = name
  }
}

let an: Animal = new Animal('1')
let pn: Person = new Person('2')

pn = an // 正确
</code></pre>
<p>注意上面代码中 name 属性实际是 public 类型，当改为 private 或者 protected 时就报错了。但如果 Animal 和 Person 类中的 name 均继承自父类，那么就可以又兼容了。</p>
<h2 id="高级类型">高级类型</h2>
<h3 id="交叉类型">交叉类型</h3>
<p>这种类型实际中没见过用。。这里还是放一下代码，自己看</p>
<pre><code class="language-typescript">function extend&lt;T, U&gt;(first: T, second: U): T &amp; U {
    let result = &lt;T &amp; U&gt;{};
    for (let id in first) {
        (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];
    }
    for (let id in second) {
        if (!result.hasOwnProperty(id)) {
            (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id];
        }
    }
    return result;
}

class Person {
    constructor(public name: string) { }
}
interface Loggable {
    log(): void;
}
class ConsoleLogger implements Loggable {
    log() {
        // ...
    }
}
var jim = extend(new Person(&quot;Jim&quot;), new ConsoleLogger());
var n = jim.name;
jim.log();
</code></pre>
<p>看一下还是很容易理解的</p>
<p>用 ES6 改写一下</p>
<pre><code class="language-typescript">class Person {
  constructor (name) {
    this.name = name
  }
}

class ConsoleLogger {
  log () {
    // ...
  }
}

function extend (obj1, obj2) {
  const result = {}
  for (let i in obj1) {
    result[i] = obj1[i]
  }
  for (let i in obj2) {
    result[i] = obj2[i]
  }
  return result
}

</code></pre>
<p>可以看到，代码实际在 extend 函数中创建了一个对象，该对象集合了 obj1,obj2 中所有可遍历的属性</p>
<h3 id="联合类型">联合类型</h3>
<p>联合类型表示一个值可以是几种类型之一。 用竖线 | 分隔每个类型，所以 number | string | boolean 表示一个值可以是 number， string，或 boolean。</p>
<pre><code class="language-typescript">interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}

let pet = getSmallPet();
pet.layEggs(); // 正确
pet.swim();    // 失败
</code></pre>
<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>
<h3 id="类型保护与区分类型">类型保护与区分类型</h3>
<p>看示例代码</p>
<pre><code class="language-typescript">let pet = getSmallPet();

// 每一个成员访问都会报错,因为我们只能访问此联合类型的所有类型里共有的成员
if (pet.swim) {
    pet.swim();
}
else if (pet.fly) {
    pet.fly();
}

</code></pre>
<p>如果想要访问到的话，需要进行 类型断言</p>
<pre><code class="language-typescript">let pet = getSmallPet();

if ((&lt;Fish&gt;pet).swim) {
    (&lt;Fish&gt;pet).swim();
}
else {
    (&lt;Bird&gt;pet).fly();
}
</code></pre>
<h3 id="用户自定义的类型保护">用户自定义的类型保护</h3>
<p>如何在类型检查后，能够清楚的知道是什么类型呢?</p>
<p>看下面代码</p>
<pre><code class="language-typescript">function isFish(pet: Fish | Bird): pet is Fish {
    return (&lt;Fish&gt;pet).swim !== undefined;
}

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}

</code></pre>
<p>pet is Fish就是类型谓词。谓词为 parameterName is Type这种形式</p>
<p>如上代码只能识别 Fish, 如果要识别 Bird 还需要写个函数</p>
<pre><code class="language-typescript">function isBird(pet: Fish | Bird): pet is Bird {
    return (&lt;Bird&gt;pet).fly !== undefined;
}
</code></pre>
<p>这样代码量增加了好多。于是有了下面的 typeof 类型 保护</p>
<h3 id="typeof-类型保护">typeof 类型保护</h3>
<pre><code class="language-typescript">function padLeft(value: string, padding: string | number) {
    if (typeof padding === &quot;number&quot;) {
        return Array(padding + 1).join(&quot; &quot;) + value;
    }
    if (typeof padding === &quot;string&quot;) {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
</code></pre>
<p>&quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;， &quot;boolean&quot;或 &quot;symbol&quot;</p>
<h3 id="instanceof-类型保护">instanceof 类型保护</h3>
<p>与 typeof 相似</p>
<pre><code class="language-typescript">interface Padder {
    getPaddingString(): string
}

class SpaceRepeatingPadder implements Padder {
    constructor(private numSpaces: number) { }
    getPaddingString() {
        return Array(this.numSpaces + 1).join(&quot; &quot;);
    }
}

class StringPadder implements Padder {
    constructor(private value: string) { }
    getPaddingString() {
        return this.value;
    }
}

function getRandomPadder() {
    return Math.random() &lt; 0.5 ?
        new SpaceRepeatingPadder(4) :
        new StringPadder(&quot;  &quot;);
}

// 类型为SpaceRepeatingPadder | StringPadder
let padder: Padder = getRandomPadder();

if (padder instanceof SpaceRepeatingPadder) {
    padder; // 类型细化为'SpaceRepeatingPadder'
}
if (padder instanceof StringPadder) {
    padder; // 类型细化为'StringPadder'
}
</code></pre>
<h3 id="类型别名">类型别名</h3>
<p>类型别名会给一个类型起个新名字<br>
看例子</p>
<pre><code class="language-typescript">type Name = string;
type NameResolver = () =&gt; string;
type NameOrResolver = Name | NameResolver;
type Container&lt;T&gt; = { value: T };
type Tree&lt;T&gt; = {
    value: T;
    left?: Tree&lt;T&gt;;
    right?: Tree&lt;T&gt;;
}

type Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;

</code></pre>
<p>与接口区别:</p>
<p>1、类型别名不能被 extends和 implements</p>
<p>2、接口创建了一个新的名字，可以在其它任何地方使用，类型别名并不创建新名字</p>
<h3 id="this多态">this多态</h3>
<pre><code class="language-typescript">class BasicCalculator {
    public constructor(protected value: number = 0) { }
    public currentValue(): number {
        return this.value;
    }
    public add(operand: number): this {
        this.value += operand;
        return this;
    }
    public multiply(operand: number): this {
        this.value *= operand;
        return this;
    }
    // ... other operations go here ...
}

let v = new BasicCalculator(2)
            .multiply(5)
            .add(1)
            .currentValue();

class ScientificCalculator extends BasicCalculator {
    public constructor(value = 0) {
        super(value);
    }
    public sin() {
        this.value = Math.sin(this.value);
        return this;
    }
    // ... other operations go here ...
}

let v = new ScientificCalculator(2)
        .multiply(5)
        .sin()
        .add(1)
        .currentValue();

</code></pre>
<h3 id="索引类型">索引类型</h3>
<pre><code class="language-typescript">function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] {
  return names.map(n =&gt; o[n]);
}

interface Person {
    name: string;
    age: number;
}
let person: Person = {
    name: 'Jarid',
    age: 35
};
let strings: string[] = pluck(person, ['name']); // ok, string[]
</code></pre>
<p><strong>keyof T</strong> 索引类型查询操作符。对于任何类型 T， keyof T的结果为 T上已知的公共属性名的联合</p>
<p>例如:</p>
<pre><code class="language-typescript">let personProps: keyof Person; // 'name' | 'age'
</code></pre>
<h3 id="映射类型">映射类型</h3>
<p>用处在于 将一个已知的类型每个属性都变为可选的</p>
<pre><code class="language-typescript">type Readonly&lt;T&gt; = {
    readonly [P in keyof T]: T[P];
}
type Partial&lt;T&gt; = {
    [P in keyof T]?: T[P];
}
type PersonPartial = Partial&lt;Person&gt;;
type ReadonlyPerson = Readonly&lt;Person&gt;;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的学生👨‍🎓时代-初中篇]]></title>
        <id>https://aiyou.life/post/GHHpY-82B/</id>
        <link href="https://aiyou.life/post/GHHpY-82B/">
        </link>
        <updated>2020-08-15T05:04:07.000Z</updated>
        <summary type="html"><![CDATA[<p>好早之前就想写这样一篇回忆性质的文章了，想把脑海中的残存的点点滴滴记录下来，可一直由于各种原因耽搁了，几天前辗转难眠，便一点一点开始回想起从幼儿园到大学毕业的点滴，有了赶快把这些记忆通过文字保留下来的冲动，遂有了这篇文章。</p>
]]></summary>
        <content type="html"><![CDATA[<p>好早之前就想写这样一篇回忆性质的文章了，想把脑海中的残存的点点滴滴记录下来，可一直由于各种原因耽搁了，几天前辗转难眠，便一点一点开始回想起从幼儿园到大学毕业的点滴，有了赶快把这些记忆通过文字保留下来的冲动，遂有了这篇文章。</p>
<!-- more -->
<p>2008年发生了好多大事，关于那年南方雪灾的记忆，也只记得是百年一遇的级别，南方损失惨重。然后的汶川7.8级大地震，成千上万的官兵进入四川救灾，温家宝总理也都去现场指挥。学校和小区里也都组织的几波捐款。那几天电视里一直播放关于地震的新闻，好像还禁网，娱乐性的东西都不让搞。北京往东北方向的哪个市的一个哥们，因为不能玩游戏在网上骂汶川地震人们死得好，结果被抓进去关了几天。然后就是后来的小升初，北京奥运会。小升初之前讲过了，说说我记忆里的奥运会。奥运会之前，北京空气的 PM2.5 严重超标，举办前几个月，北京就禁止福建周边🈲各个工厂停工，限制车辆通行等等，后来空气质量果然好转了很多。再后来温家宝总理在哥本哈根气候大会上做出了减排多少的承诺。言归北京奥运会，他是张艺谋导演的一场大型盛会，主场馆是可容纳十万人的鸟巢，在奥运开幕式当天，我们中国代表队是由姚明和汶川地震的小英雄带领的队伍，这届奥运会我们拿了最多的奖牌和金牌，然后美国🇺🇸排的第二。</p>
<p>我们那里有个习俗，每个12年叫做本命年。第一个12年，也就是12岁，我们要进行一个圆锁的事情。那个时候，父母会宴请四方，在饭店里吃一顿，就像办婚礼的那种样子。我12岁的时候，我爸妈订的饭店是新世纪烤鸭店，虽然这名字感觉像是个卖熟食的街边小店，但其实这是个气派的大酒店，也不知道这家店老板怎么想的，给好好的酒店起个这样的名字。我那个时候真是太呆了，礼仪小姐姐在典礼开始前叫我记住一段话，在典礼开始时背下来，可我表现的真是一言难尽。同样因为这个事情，我家搬到了同煤一中对面，家里换了30多寸的液晶大电视，还添了一台电脑。电视第一次搬到家里时，我记得我打开了CCTV4频道，还看了半天的《哪吒传奇》。那时的电脑大都还是使用的是那种方方正正的大显示器，我们土话叫做大个蛋，装的系统是 WindowsXP，电脑里还有很多电影和单机游戏，那是我第一次接触电脑，真的是好奇的很。我妈怕我迷恋网络游戏，就没让我爸给家里的电脑连网，但没联网也没有阻挡我探索的热情，在初中三年里，我买了好多好多电脑杂志，基本是出一期，我就会买一本，有《电脑爱好者》、《电脑迷》、《电脑报》、《网友世界》等等，书里的内容和媒体光盘📀给我的初中带来了很多快乐。</p>
<figure data-type="image" tabindex="1"><img src="https://aiyou.life/post-images/1597496643143.png" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">圆锁</div>
<p>初一开学的第一天，黄远谊让我们带着红领巾，排着队。带红领巾让我这个初中生还有点难为情...我的初中第一个同桌是叫个什么来着，只记得她还跟我比手指来着。第一个暗恋的妹子叫曹敏琪哈哈，算是一见钟情吧，对她印象最深的有两个场景，一个是某个周五下午，我和一个哥们在体育场打乒乓球，她和她的一群伙伴在体验场台阶看着，那个下午，橙色的阳光渲染的那个景象真的很美。另一个场景是某次课间，她突然回头一直盯着看我，我勒个丢嘞，应该有1分多钟，搞的我真的是心里砰砰跳，眼睛👁不知道该看哪里，最后实在慌的不行，就往桌子上一趴，头埋在两个手臂里。</p>
<figure data-type="image" tabindex="2"><img src="https://aiyou.life/post-images/1597496530214.png" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">黄远谊</div>
<p>那年，我总捣鼓家里的没联网的电脑，我爸妈每晚很晚回家，每次回家总能抓到我玩电脑，所以他们就把电脑拆了几部分，放到了家里的各个角落。可是每次放学，回到家后我第一时间把电脑组装好，瞎捣鼓了起来，算好我爸妈回家的时间，我又拆成几部分归到原处。某次，键盘失灵了，系统也不知怎么需要输入密码才能进去，我输入密码，可怎么也输不进去！！气的我一个劲的锤那个垃圾键盘。跟同学那里取经得知，需要重装系统，我不知道重装系统时什么意思，就在周六的时候，一点一点把电脑拆了，然后一点一点的再装回去，电脑主板上有上百个各种各样的插槽，拆下来的时候好拆，可怎么再装回去呢?稀里糊涂的装了回去，插上电源开机看了看结果，然后主板上电容就爆💥了，冒烟且带着焦臭味。那可急坏我了，我又尝试了几遍，电脑却再也打不开了。我紧急把电脑主机还原，没有让我爹看出破绽。然后某天，我抱着主机去修电脑的那里问了问价钱，后来我就偷钱把主板给修好了。。。。很多年后，我跟我爹走进了那家店，那老板一看见我，就跟我爹说我当年抱着主机去找他修电脑来着，我了个草嘞！！！出了那家店，我爹问起此事，我支支吾吾，忘了如何作答。。。</p>
<figure data-type="image" tabindex="3"><img src="https://aiyou.life/post-images/1597479310217.jpg" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">布局图</div>
<p>2009年春节前后，我妈给了我300让我给她买一台诺基亚1080和电话卡，我买了一个国产的能用QQ的手机和买了一个联通电话卡。这个手机是基于MTK平台的，当时基于这个平台，有国产的斯凯系统，网上有好多这个平台的各种软件，可惜，在安卓流行之后，斯凯也死掉了。我当时真的是用这款手机玩出了各种花样，印象最深刻的是一个刷钻软件，这刷钻软件是真的吊，点击一键刷钻，四五条短信发出去，回复绑定QQ的短信，一个QQ钻就有了。。当时为了QQ升级的快，还偷偷用我爸手机开通了超级QQ。每月扣他10块钱话费。</p>
<figure data-type="image" tabindex="4"><img src="https://aiyou.life/post-images/1597506820606.png" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">初二发表的第一个说说</div>
<p>初二的时候，我借故已学习的理由跟我爸妈提出要买学习机，后来在当时的超人手机广场二楼看了很火的濮存昕代言的诺亚舟的一款，感觉它好酷啊，我好想要。可那一款要2400多块，这在当时可不是一笔小钱。我爸妈当然也没有给我买，失落了好久，我妈带我去买了很火的好记星v1+。学习机这种东西其实并没有什么卵用的，自从买来学习机，我基本就没用他学习过。相反，我从买来的杂志的光盘里，通过电脑，拷贝出了很多小说、电影、音乐。看的第一本小说是《坏蛋是怎样炼成的》，当时迷恋这本小说迷恋的厉害，每天除了上学，放学回家就在用学习机看这本小说，作业也不写了，学习成绩也一落千丈。不过也是坑啊，当时的作业也是好多，每门功课都要花个1个多小时到2个小时去写。。在黄远谊的课上，她要求我们每个星期的值日生都学一首英文歌，由于这个原因，我开始在附近的修电脑的店里下载音乐什么的，一块钱还几十首来着。我拿着我的学习机，在他店里下载了好多好多音乐，我很怀念那时候拿着学习机听歌的日子。</p>
<p>也是在初二的时候，我竟然在家里发现我爸妈在衣柜里藏了一台未开封的笔记本电脑，联想昭阳E43。那个下午真的是异常兴奋，我也清晰的记得开箱后的属于电子产品那个味道，再次闻到这个味道是在几年后大二开箱15款的 MacBook Air 11’的时候。 打开笔记本，我连接了周围未加密的WIFI： TP_4*7A，第一次进行了网上冲浪，我用IE打开了百度，搜了一下关之琳的图片，当时看了她的一部鬼电影，感觉她真好看啊。后来下载了QQ，第一次登上QQ后，右下角弹出个框说我中了一台价值5000多的三星笔记本电脑，我是那个兴奋呀。可我银行卡，手机号什么的都没有，就把我的名字，我家地址和我把手机号提交上去了，然后就等着腾讯某天给我把电脑发过来。我把这件事告诉了我哥，他告诉了我爸妈，当天晚上我爸妈回来，就把笔记本又藏到了别处，然后我又找了出来。蹭网蹭的过分了，影响到了人家正常使用，导致周围唯一没有加密的WIFI也终于加了密。当时市场上流行卡皇、卡王蹭网设备，能搜索到半径200米之内的设备信号，我一个初中生没钱买这些设备，只有去书店里看书研究蹭网，也间接的导致我有一些简单的 Linux 和 网络知识。书店里我买了一本杨哲写的《无线黑客傻瓜书》，接触到了第一个Linux(BackTrack3)，了解到破解加密格式为WEP、WPA的WIFI密码，监听破解蓝牙、WIFI传输的数据包等等。不过可惜的是，当时我的笔记本无线网卡是英特尔的，对破解工具的支持不是很好，所以我抓了一晚上的包，都没有解析到多少有用的信息。。2009年年底，Windows7发布前夕，我从书店杂志里的光盘中获得了Windows7预览镜像，第一时间装到了我的笔记本上，那种新鲜感后来再也没有感受到。。盗版Windows7只能使用 30 天，于是网络上好多公司开发了软件延长 Windows7 使用时间，记忆中包括 360，win7优化大师等软件。那时很喜欢体验捣鼓各种软件，卡巴斯基、小红伞、诺顿、瑞星、江民软件、360、金山毒霸、windows优化大师(Z武器-鲁大师)、win7优化大师、驱动精灵、魔法超级兔子、千千静听等等。360免费杀毒的出现，导致瑞星，江民软件这些暴利的杀毒软件卖不动了，也导致了后来的软件越来越没有节操，安装卸载使用过程中诱导添加点击劫持各种各样的推广。。在某本杂志的光盘中，有个病毒样本，我想试试这病毒有啥可怕的，就直接双击了，结果我硬盘所有的文件都打不开，那天晚上，我花了一整晚的时间安装新系统。直接忙到第二天早晨6点。。</p>
<p>2010年还发生了著名的3Q大战，起因是腾讯推出一款和QQ深度绑定的软件QQ医生和360进行竞争，360于是推出一款360隐私保护器和后来的360扣扣保镖，进行监控扫描提醒用户QQ行为。那时从杂志光盘中搞到过这样一款软件，觉得还蛮好用的。搞到后来，腾讯做出了一个“艰难的决定”，要求用户二选一。又过了几天联网之后，这软件就不能用了。360改变了自己硬朗的商标的风格，腾讯也变得更加开放。</p>
<figure data-type="image" tabindex="5"><img src="https://aiyou.life/post-images/1597497031656.jpeg" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">二选一</div>
<p>初三我转到了270班，班主任是李月芳。初三最印象深刻的是，我们班一个妹子跟一个大学生搞对象，这多少有点震惊了我当时的世界观。2011年年初，我他喵的嘴贱跟一个妹子间接就歼20首飞搭了个讪，那让我现在非常后悔。在补习班的时候，还遇到了小学同学吴迪，不过也没跟她说什么话...</p>
<p>初中毕业后，我第一次去网吧。当时还不懂的去网吧的流程，我就邀请同学刘晓江花了几块钱一起去上网了。忘了第一次在网吧里干了点啥，可能就是单纯的想去学点上网流程的经验吧...现在想来，我还没有去过酒吧，迪厅，洗脚城，大保健之类的场所，有机会找个同事带我去长长见识。</p>
<p>本来想着初中篇没什么可写的，可写着写着，不知不觉花了将近一天时间，写了也有几千字。其实通篇也可以看出，初中花在学习上的时间上没有很多，老把心思花到了一些奇奇怪怪的事情上。我很开心也很遗憾有那些经历，让我收获和失去了很多东西。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的学生👨‍🎓时代-小学篇]]></title>
        <id>https://aiyou.life/post/YNnCC51T0/</id>
        <link href="https://aiyou.life/post/YNnCC51T0/">
        </link>
        <updated>2020-08-09T15:55:33.000Z</updated>
        <summary type="html"><![CDATA[<p>好早之前就想写这样一篇回忆性质的文章了，想把脑海中的残存的点点滴滴记录下来，可一直由于各种原因耽搁了，几天前辗转难眠，便一点一点开始回想起从幼儿园到大学毕业的点滴，有了赶快把这些记忆通过文字保留下来的冲动，遂有了这篇文章。</p>
]]></summary>
        <content type="html"><![CDATA[<p>好早之前就想写这样一篇回忆性质的文章了，想把脑海中的残存的点点滴滴记录下来，可一直由于各种原因耽搁了，几天前辗转难眠，便一点一点开始回想起从幼儿园到大学毕业的点滴，有了赶快把这些记忆通过文字保留下来的冲动，遂有了这篇文章。</p>
<!-- more -->
<h2 id="小学篇">小学篇</h2>
<p>二年级前我换了好几所学校，校北街小学-&gt;汇林小学-&gt;校北街小学-&gt;实验小学。也记不得什么缘由，老是换学校，导致我上一年级时比别人迟了一年。</p>
<figure data-type="image" tabindex="1"><img src="https://aiyou.life/post-images/1596990013375.jpeg" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">学校布局图</div>
<p>在实验小学的第一个班主任姓范，也是个25左右的年轻女老师，很严厉，下午写不完作业不让走的那种，那个冬天，穿着大棉裤的我在座位上尿裤子了。对她印象最深的一件事是: 不记得我们犯了什么错，我们全班被罚站，她拿着一根1米长的黄色木尺子一个一个的打我们，最后竟把尺子打断了。</p>
<p>二年级的时候，我的同桌是个小美女樊佳星，她要转学到校南街小学。转学前的最后一节课，这个家伙坐到了小帅哥王浩的旁边，我记得我心里隐隐有些失落。十几年后（大学毕业），路过华亿摩尔城下的电影院时，我在人群中一眼就认出了她，她挽着他男朋友的胳膊有说有笑。而我早已撇过头，眼泪不自觉的往下流，哭成了泪人😭😭😭😭。（开玩笑的，虽然认出了她，但也没啥感觉，就是觉得这么多年过去了，感觉她还是小时候的样子，很新奇）</p>
<p>三年级的时候，班主任换成了戴玉霜。戴玉霜是别人口中公认的教学能力强的好老师，我们是她当班主任带的最后一届学生，之后她就当思想品德的代课老师去了。她是一个四五十岁的女人，很精致。或许她在教书上很有水平，但在育人上有很大欠缺。不知出于什么目的，她让我们班长的最高的徐昕和邓雅婷，和最胖的郑鹏飞和我拿着椅子上讲台，我们在讲台上坐成一排，摇头晃脑的一遍又一遍的背诵古诗。下面同学们笑成一团，那让我很受辱。我们班有个女生走路有点歪斜，戴玉霜让她一圈一圈的在全班同学注视下绕着班里走。</p>
<p>三年级的时候发生了一件大事，区里几个小学3-6年级的学生要到附近的体育馆里参加一个演出。我们三年级一班是我们学校第一个出发的。那是我人生中第一次参加这种事。在体育馆里，很多领导，我们班蔡琦上台进行了主持。现在想想，还真是佩服他啊。记忆中，还有他在舞台上飒爽的英姿。</p>
<p>应该是四(五)年级的时候，某天放学几个同学一起走，不知道体委从哪里摸来的摔炮(就是往地上摔一下就炸的炮)，走一路，往地上偷偷放了一路炮，就等着来来往往的人无意踩到，后来我们越来越过分，偷偷往卖菜的店家门口放，在小区的健身器材上放。这些恶作剧那时真是笑死我了。尤其是吓人一跳的时候。</p>
<p>学校到家有两个公交车车站的距离，步行🚶最多半个小时，我每次上学，都会要一到两元钱，坐公交，买煎饼🌯吃。那时的煎饼一块钱一个，我最喜欢吃里面带的饼，有时候还会加一个卫龙，香啊!!!那时候虽然会要钱说坐公交，其实我总是步行回家，一是因为我总买学校对面5毛一个的冰激凌，一是我想和同学一起走，一起玩。上学途中，总喜欢在路边驻足看看卖鱼商贩的池子里的各种鱼、乌龟、蚯蚓...如今那里改成了商业步行街，卖鱼的大爷也不知哪里去了。</p>
<p>不知何时起，我骑自行车上下学了，花了200多买的一个小的蓝色的自行车。我还记得某天中午骑车上学，骑着骑着遇到前面有一只小松鼠🐿，被我吓的在我前面使劲跑，我也疯狂的蹬轮子，跟它赛跑。结果还是这家伙跑的快呀。那时我把自行车停到了附近的五虎便利店的门口，不知道什么时候起，我的自行车老被人放了气，那时候的自行车不像现在的，那时自行车只需要把气门芯弄下来，气就被放没了。我真的气死了，每天要备着5毛钱推着车去买气门芯。后来自行车搞丢了，又买了一辆 lady 自行车，那时山地车还是稀罕货，自行车充气方式和现在一样了，不需要什么气门芯了，车停在便利店的第一个中午，自行车充气口的车帽就被人弄下来拿走了。。现在想来，这他喵的是什么鬼人！！！</p>
<p>后来，我爸给我报了一个接送车，我们那里叫做耗完儿车，就是三轮车外面全包裹的那种，现如今大部分都取缔了。每次坐车的有5，6个人，我们车上有个哥们也特别淘气，有次中午在放学途中，我们的车在路上开着，路过一个推着小车打着竹板卖蟑螂药的，这个哥们也不知道是发什么神经，立马打开窗户，唾了卖蟑螂药的小哥一口，这个小哥是那个气呀，可他两条腿怎么追的上我们的轮子。。可是可是可是，我们的车刚走没到50米，居然堵车了，这小哥看机会来了，飞快的追上了我们，从窗户上又唾了回来，精准的落到了之前唾他的这个哥们上，那口水量，我他喵的怀疑这是准备了几天吧..........还是这哥们的事，还是放学途中，他从兜里摸出了黑蜘蛛炮和打火机，在我们开车正要超过前面的耗完儿车时，这个逼点燃了炮，从窗户精准的丢进了旁边的车窗中。旁边司机师傅没有发现，炮突然就在他车里炸了，然后他的车就停到了大马路中央。车里的我们笑的前仰后合。(现在想来，真的很不应该)</p>
<p>再后来，我去了小白杨服务站，这是一个中午在这里吃饭睡觉，晚上写作业等父母接的地方。我很怀念我和赵英明，高志远中午借故不去睡觉，一起看泰罗奥特曼，葫芦娃的时光。记得某天晚上的放学回到服务站，我们早早写完了作业，就在教室里玩起了纸飞机，我折的火箭精准的垂直的插到了当时六年级的师姐的丸子辫子里，当时真是笑死我了。可我还没高兴多久，我就被服务站的老师打了一顿出院子玩去了。</p>
<p>六年级的时候，小白杨服务站旁又开了一家小天使服务站，戴玉霜天天在我们班里，针对我们几个住服务站的学生轮番的让我们去小天使服务站，讲了很多次，被她搞烦了就答应她了。第二个星期一中午放学，我依旧走进小白杨的大门，下午戴玉霜就找到我，问我为什么不去小天使......就这样被戴玉霜劝到了小天使，现在想起来，那时她要是没收钱，我是打死也不信...小天使中也有几个同学，吴迪和郑鹏飞。在这里也遇到了两个很好看的短发的妹子，一个是郭小曼，一个忘了叫啥了。我记得我暗恋郭小曼来着，但是她比我大，还跟我不是一个学校小的，她是服务站阿姨的侄女。。现在不知道她干啥去了。</p>
<p>教育局发下文件，得知了这届六年级要考英语，这下不仅学校慌了，我们也慌了。因为自三年级开设英语课来，我们的英语课基本是走个过场，没怎么学。到六年级时，我连一个Yes和No都不会写。我不知道其他班的情况是什么样，戴玉霜让我们全班去报英语补习班，一个一个检查，去报位于文化活动中心的英语补习班。</p>
<p>2008年的小升初考试。英语老师带头偷偷的在考场后门门缝里递小纸条。那是我第一次感受到不公。我记得那年我语文考了78分，数学是84(86)，自然94，英语 40 几分。当给我妈打电话报分数时，我记得我带着哭腔...我妈从小就很体谅和溺爱我，她安慰我说尽力就好。</p>
<p>大学毕业后的某天夜晚，我出门溜达，走过天桥下楼梯时遇到了戴玉霜，也是一眼就认出了她，但我什么也没说，什么也没做。也愿她一路顺风吧。</p>
<p>小学时的我每天脏兮兮的，不受老师和同学们待见，那时我真的很小心很小心的保护自己的校服不被弄脏，可也不知道为什么，它总是不知不觉就脏了。我老爸每天忙完活，大晚上还要给我洗衣服。我一直觉得小学改变了我，成就了我自卑的心理，一直影响我到现在，至未来。</p>
<p>小学同学还记得很多，爱翻白眼的假小子班长王茜，二胡拉的很棒的小个子学习委员曹靓宁，身强体壮的体育委员康逸群，胳膊上绣着红袖章的一本正经的蔡琦，高挑的脸有点方跑步冠军的宣依(貌似是5年级时去上海了)，会吹赛克斯的赵喆，爸爸在同煤一中工作的赵影哲，特别瘦的外号锅盔的郭堃，一起看泰罗奥特曼的赵英明高志远，有点小帅气的痞子混子王浩，少根筋的张一鹏，班花赵融，送我一只小兔子的刘浩强，哭鼻子的沙包丢的棒的孟帅，被飞来的石子砸中额头的吴迪，六年级时跟一年级打架的张艺耀，做操时被强迫牵手的吉蕾，脸有点圆的王学敏，假小子邓婌贤，画画特别吊的唐鹏霄，经常混在女生群里的高志远，还有候彧，候小星等等等等.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[我的学生👨‍🎓时代-幼儿园篇]]></title>
        <id>https://aiyou.life/post/6AOKgckv2/</id>
        <link href="https://aiyou.life/post/6AOKgckv2/">
        </link>
        <updated>2020-08-07T15:53:47.000Z</updated>
        <summary type="html"><![CDATA[<p>好早之前就想写这样一篇回忆性质的文章了，想把脑海中的残存的点点滴滴记录下来，可一直由于各种原因耽搁了。几天前辗转难眠，便一点一点开始回想起从幼儿园到大学毕业的点滴，有了赶快把这些记忆通过文字保留下来的冲动，遂有了这篇文章。</p>
]]></summary>
        <content type="html"><![CDATA[<p>好早之前就想写这样一篇回忆性质的文章了，想把脑海中的残存的点点滴滴记录下来，可一直由于各种原因耽搁了。几天前辗转难眠，便一点一点开始回想起从幼儿园到大学毕业的点滴，有了赶快把这些记忆通过文字保留下来的冲动，遂有了这篇文章。</p>
<!-- more -->
<h2 id="幼儿园篇">幼儿园篇</h2>
<p>我是在一家私人幼儿园上的课，幼儿园开设在乡镇中学的操场中，教我的是一对年轻的夫妻，想来年龄和我如今差不多。那女老师姓杨，男老师不怎么记得了。幼儿园毕业后，再次见到男老师时，已是七八年后了。他似乎是在集市做着倒卖蔬菜的生意，皮肤黝黑，脸上布满沧桑，没有当初模样。后来听父母说起，女老师患了重病，花了一大笔钱，幼儿园便开不下去了。希望他们如今身体健康，平平安安吧。</p>
<figure data-type="image" tabindex="1"><img src="https://aiyou.life/post-images/1596988645375.jpeg" alt="" loading="lazy"></figure>
<div style="text-align:center;font-size:80%">学校附近布局</div>
<p>幼儿园时期，是我在身高方面最自豪的一段时期。因为我在我们班男生里面是个子最高的，唯一比我个子高的，是个叫王儒的女孩。可能是身材魁梧，导致我在幼年时期嚣张跋扈，我清晰的记得我和一个嘴贱的小个子李强打架，导致他的头磕到了桌角后，去医院缝了三针。后来他妈妈来幼儿园找到我，不记得骂我些什么了，只记得男老师不停的在劝。幼儿园毕业几年后，又和李强在补习班里遇到了，这家伙嘴还是那么贱，忘了什么缘由，我又把这个逼给收拾了一顿，把他从半米多高的台阶上踹了下去，现在想来还有点可怕。</p>
<p>想起了个搞笑的事，我们班上有个叫王帅帅的，不知是我找他抄作业还是怎的，我俩在中学操场对面遇到了，也还不记得是什么原因，我竟和他攀比了起来，我说我会吃纸，并撕了一点作业本纸吃了表演给他看，他说谁不会吃，结果吃了一大坨纸，当时我无话可说，还有点佩服他。</p>
<p>幼儿园时记忆最深的一件大事，应该是庆祝六一儿童节。杨老师带我们排练跳舞，六一当天，操场上站了好多人，我们在表演。我记得那天我穿着统一的红色短袖，脸被涂的白白的，额头上有个红点，貌似还涂了一点口红。那天下午放学后，我看到一个骑蓝色的老式摩托的人，背后坐着的叔叔手里拽着庆典上用的一个很大很大的红的圆气球🎈，我当时有想这个人会不会飞到天上去啊。</p>
<p>那个时候玩的很好的伙伴有陈鹏陈凯兄弟俩，他俩十分淘气，经常穿拖鞋上学。某天我也学他俩，穿着拖鞋去上学了，结果上学途中嬉笑打闹，跑路的时候，拖鞋面断了。我忘了我是怎么走到的幼儿园，男老师把他的灰蓝色的还有点高档的拖鞋给我穿，撑了一下午。小学时我们也一起玩，他俩的身手是真的好，翻跟斗爬墙什么都不在话下，我记得我们那里有一个荒废了的水塔，水塔旁断壁残垣，这俩兄弟经常在几个房顶上跳来跳去，我也想上去玩，可上房顶的要先爬上1米多高的，一块独立的脚下只能踩到只有两块砖细小的残墙。这一米多高的墙我都翻不上去，更别说再在上面行走了，后来这兄弟俩一人站一边，把我拽了上去。上去之后是真的要吓尿了，深怕一个不小心掉下去。。</p>
<p>凭记忆，写一下那时候的小伙伴的名字<br>
王儒、杨露、李强、王帅帅、张智(小虎)、李星茹、王亚亚、李琪、张正阳、王超...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用树莓派搭建个人服务器]]></title>
        <id>https://aiyou.life/post/4xGLEq7xe/</id>
        <link href="https://aiyou.life/post/4xGLEq7xe/">
        </link>
        <updated>2019-11-21T02:41:18.000Z</updated>
        <summary type="html"><![CDATA[<p>大学时用的腾讯云优惠到期了，续费要每个月60多块钱，有点肉疼。因而买了一块树莓派，想要研究一下怎么将他搞成一个服务器。拖拉了几个月，最近总算是搞好了。本文将介绍一下我的搭建过程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>大学时用的腾讯云优惠到期了，续费要每个月60多块钱，有点肉疼。因而买了一块树莓派，想要研究一下怎么将他搞成一个服务器。拖拉了几个月，最近总算是搞好了。本文将介绍一下我的搭建过程。</p>
<!-- more -->
<h2 id="物料准备">物料准备</h2>
<blockquote>
<ul>
<li>服务器一台。我使用树莓派当服务器。对于性能有需求的，可以考虑使用电脑主机或者买台物理服务器。注意平衡好功耗与性能的关系，毕竟一台电脑主机或物理机24小时开机，耗电量也不小。</li>
<li>智能路由器一台。我家用的斐讯K2，刷了潘多拉系统。智能路由器意味着系统是基于OpenWrt的，可以安装各种软件。</li>
<li>互联网。这里单独列出来，是因为对互联网也有要求。网络需要有公网IP,最好开放了80端口。很多互联网服务提供商(ISP)给用户提供的都是经过NAT转发的内网地址，并且屏蔽了80端口。这种情况下，可以打电话到ISP客服要求给调成公网IP和开放80端口。当然实在调不了，可以使用内网穿透来解决公网IP的问题，但端口就无能为力了，访问的时候，只能配合端口来访问。</li>
</ul>
</blockquote>
<p>当然，服务器直连互联网也是可以的。这样的话，搭建过程更简便，缺点是网络利用率低。</p>
<h2 id="地址解析">地址解析</h2>
<p>尽管ISP分配给我们了公网IP，但很大程度上公网IP是随着每次拨号会不停变动(比如家里停电、重启路由器等都会重新拨号)，每次拿到的将是一个新的公网IP。我们知道，两个端通信的前提是知道对方的IP地址，IP地址变动的话，将不能通信。举个简单的例子:我和小明经常打电话，有一天小明把电话号换了，我打他原来的电话号，就可能无人接听或者被其他陌生人接到了，那在这个时候，我只能去他家跑一趟，问问他的新电话号，以后我俩就又能互相打电话了。域名就是他的家庭地址，IP就是电话号。我们可以根据域名通过DNS服务来获取IP。有人可能会疑惑，公网IP变动后，域名是怎么知道你的IP变动呢?</p>
<h3 id="ddns">DDNS</h3>
<p>DNS我们都知道是用来将域名解析成IP的。那DDNS是什么?DDNS（Dynamic Domain Name Server，动态域名服务）是将用户的动态IP地址映射到一个固定的域名解析服务上，用户每次连接网络的时候客户端程序就会通过信息传递把该主机的动态IP地址传送给位于服务商主机上的服务器程序，服务器程序负责提供DNS服务并实现动态域名解析。<br>
由上述概念可知，只要我们在路由器每次联网时，监控IP地址变动，就有办法更新DNS解析记录。那怎么完成监控和更新?</p>
<h3 id="阿里ddns">阿里DDNS</h3>
<p>提供类似服务的厂商有很多，国内做的最好的还是阿里。相关文档点击<a href="https://help.aliyun.com/document_detail/141482.html">这里</a>..里面参考代码给的是Java版本的。其他实现可以在GitHub上搜一下。个人觉得最好还是选择bash实现，使用Cron定时任务定时执行就行。</p>
<p><strong>注意</strong>:有些智能路由器里本身就带有这个功能，无论是固件集成还是插件形式的。</p>
<p>如图所示，我家路由器固件集成了阿里DDNS<br>
<img src="https://aiyou.life/post-images/1574309892496.png" alt="" loading="lazy"></p>
<h3 id="域名">域名</h3>
<p>对域名其实没有什么要求，阿里云上随便买一个就行了。很便宜，10年只要60多块。<br>
如图所示<br>
<img src="https://aiyou.life/post-images/1574311032422.png" alt="" loading="lazy"><br>
记录前四条，是指向GitHubPage，也就是本博客的地址。阿里DDNS配置正确的话，会自动生成最后一条记录，地址指向了我家的路由器。</p>
<h3 id="内网穿透">内网穿透</h3>
<p>上面介绍的前提是你有公网IP的情况下。没有公网IP只能靠内网穿透来提供Web服务。相关教程可以Google查看。<br>
内网穿透优点是不需要公网IP，缺点是依赖服务提供商的稳定性，且不能自定义域名。如果人家服务器挂了，或者域名到期了，你这里也不能用了。</p>
<p><strong>注意</strong>: 有些智能路由器里本身就带有这个功能，无论是固件集成还是插件形式的。</p>
<p>如图所示，我家路由器固件集成了内网穿透工具<br>
<img src="https://aiyou.life/post-images/1574312158496.png" alt="" loading="lazy"></p>
<h3 id="验证">验证</h3>
<p>地址解析配置完成之后，需要验证一下是否解析成功</p>
<pre><code class="language-bash">ping -c 4 www.aiyou.life
</code></pre>
<p>查看解析到的IP是否与公网IP一致</p>
<p>如图所示<br>
<img src="https://aiyou.life/post-images/1574312401056.png" alt="" loading="lazy"></p>
<h2 id="端口转发">端口转发</h2>
<p>地址解析配置完成后，所有通过域名的访问都将直接请求到了路由器上。所以需要通过端口转发，将请求转到内网中的服务器上。这一步其实很简单，只需要记住几个常用的端口，配置一下就行了。</p>
<p>如图所示，来自互联网的80端口请求，都会转发到我的树莓派服务器(192.168.111)上。<br>
<img src="https://aiyou.life/post-images/1574313048391.png" alt="" loading="lazy"></p>
<p>这一步验证也很容易，在服务器上装个Nginx即可。然后通过域名访问，查看是否转发到了Nginx页面。</p>
<p>如图所示，即为成功（Chrome和Safari都把www给隐藏了，实际完整地址是 www.aiyou.life）<br>
<img src="https://aiyou.life/post-images/1574313486613.png" alt="" loading="lazy"></p>
<h2 id="应用转发">应用转发</h2>
<p>当只有一个静态应用时，只需要替换一下Nginx默认的文件就可以了。但我们的服务器肯定不止部署一个应用，且也不一定是静态的。因而需要考虑使用Nginx进行正向/反向代理。阿里DDNS理论上应该是支持多域名指向同一个IP地址的。这样的话，我可以为每一个应用分配一个二级域名，Nginx代理配置不同的server_name即可。但我尝试了半天也没有试成功。所以只能根据访问路径，代理到不同的应用。</p>
<p>配置代理时需要仔细查阅Nginx文档<br>
如图所示，昨天被这两个 / 坑了一天时间😭<br>
<img src="https://aiyou.life/post-images/1574314812013.png" alt="" loading="lazy"></p>
<p>转发到其他应用时，只需要再添加一个 location 即可。</p>
<h2 id="结语">结语</h2>
<p>现代智能家用路由器大都基于OpenWrt系统，而OpenWrt是基于Linux专为路由器打造的系统。路由器作为家庭网络中枢，其实功能是很骚的，可玩性很强。虽然路由器配置不高，但乐趣不就是在有限的资源中搞出不同的花样吗?</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于提高setTimeout与setInterval精确度的探索]]></title>
        <id>https://aiyou.life/post/kokne79MF/</id>
        <link href="https://aiyou.life/post/kokne79MF/">
        </link>
        <updated>2019-11-10T09:54:20.000Z</updated>
        <summary type="html"><![CDATA[<p>我们都知道，setTimeout与setInterval都不是精确的计时器，它还与当前主线程任务队列中的任务大小数量有关。当主线程任务队列的任务没有执行完毕时,setTimeout与setInterval就不会准确的在 t 时间后运行。那怎么才能提高二者的精确度呢?</p>
]]></summary>
        <content type="html"><![CDATA[<p>我们都知道，setTimeout与setInterval都不是精确的计时器，它还与当前主线程任务队列中的任务大小数量有关。当主线程任务队列的任务没有执行完毕时,setTimeout与setInterval就不会准确的在 t 时间后运行。那怎么才能提高二者的精确度呢?</p>
<!-- more -->
<h2 id="1-settimeoutsetinterval用法">1. setTimeout/setInterval用法</h2>
<p>这里还是简单提一嘴吧。这两个函数是定时器函数，setTimeout表示回调函数在 t 时间后运行，setInterval表示回调函数每隔 t 时间运行。</p>
<pre><code class="language-javascript">setTimeout(function(){
    ...
}, t)

setInterval(function(){
    ...
}, t)
</code></pre>
<div style="text-align:center;font-size:80%">代码 1.1</div>
<p>在 CSS3/HTML5之前，二者常用来绘制页面动画。CSS3/HTML5之后，常用css来绘制动画。另外还一个API是requestAnimationFrame. 该函数与setInterval类似，区别在于该函数没有 t 参数，默认是屏幕刷新的每帧调用一次。每秒调用（1/屏幕刷新率）次</p>
<pre><code class="language-javascript">requestAnimationFrame(function(){
    // DOM动画
})
</code></pre>
<div style="text-align:center;font-size:80%">代码 1.2</div>
<h2 id="2-发现问题">2. 发现问题</h2>
<p>Js是一个单线程语言，同一时间只能做同一件事情。这很好理解，如果同一时间能做多个任务，那么多任务都在操作DOM时，页面该怎么显示呢?因而JS设计为了单线程,但单线程也带来了一些问题，比如线程阻塞，CPU利用率不高等问题。看代码2.1</p>
<pre><code class="language-javascript">setTimeout(function () {
    console.log('task finished after ' + (Date.now() - startTime) + 'ms')
}, 0)

for (let i = 0 ; i &lt; 9000 ; i++) {
    console.log(5 + 8 + 8 + 8)
}
console.log('主线程复杂任务耗时:' + (Date.now() - startTime) + 'ms')
</code></pre>
<div style="text-align:center;font-size:80%">代码 2.1</div>
<p>执行结果如图 2.1 所示<br>
<img src="https://aiyou.life/post-images/1573436890372.png" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">图 2.1</div>
<p>for循环是一个耗时任务,阻塞了setTimeout的执行。我们设定0秒后执行输出，可实际结果是在1243ms之后输出，所以setTimeout的 t 参数定时不够精确。</p>
<!-- **结论**: *主线程里实际上是没有办法精确按时执行setTimeout/setInterval的回调函数。当浏览器js引擎解析代码遇到 setTimeout/setInterval 时，会将他们注册到下一个宏任务队列，只有执行完当前宏任务队列和微任务队列中的任务后，才会执行下一个宏任务队列中的任务。代码的执行本身就消耗时间*。 -->
<p>关于事件循环、宏任务、微任务不是本文重点，感兴趣的可以看看这篇文章<a href="https://juejin.im/post/5bac87b6f265da0a906f78d8">笔试题——JavaScript事件循环机制（event loop、macrotask、microtask）</a></p>
<p>那么到底要怎么解决精确度问题呢?</p>
<h2 id="3-解决问题">3. 解决问题</h2>
<p>前文我们一直在提及主线程主线程的，那么有没有办法利用其它线程进行计时呢?当代码执行到特定位置，通知其它线程中开始计时任务，主线程继续完成复杂任务，那么就不会阻塞计时器的运行，这样的话计时精确度就提高了。那么问题来了，JS不是一门单线程语言吗，怎么能利用除了主线程之外的其他线程呢?</p>
<p>在HTML5中，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker">Worker</a>的引入使得我们有了利用其它线程的能力。注意:<strong>Worker中不能操作DOM</strong>。</p>
<p>事情好办了。洋洋洒洒写下如下代码:</p>
<pre><code class="language-javascript">// worker生成器
const createWorker = (fn, options) =&gt; {
    const blob = new Blob(['(' + fn.toString() + ')()']);
    const url = URL.createObjectURL(blob);
    if (options) {
        return new Worker(url, options);
    }
    return new Worker(url);
} 
// 生成worker
const worker = createWorker(function () {
    onmessage = function(e) {
        console.log('进入WebWorker')
        let count = 1
        let startTime = Date.now()
        let timer = setInterval(function () {
            if (count++ === e.data) {
                clearInterval(timer)
                postMessage(startTime)
            }
        }, 1000)
    }
})

// 将代码2.1中的setTimeout替换为了 worker
// worker线程任务
const startTime = Date.now()
worker.postMessage(10)
worker.onmessage = function (e) {
    console.log('Worker线程任务内部耗时:' + (Date.now() - e.data) + 'ms')
    console.log('Worker线程任务耗时:'+ (Date.now() - startTime) + 'ms')
    this.terminate()
}
// 主线程任务
for (let i = 0 ; i &lt; 5000 ; i++) {
    console.log(5 + 8 + 8 + 8)
} 
console.log('主线程复杂任务耗时:' + (Date.now() - startTime) + 'ms')
</code></pre>
<div style="text-align:center;font-size:80%">代码 3.1</div>
<p>代码中, worker 线程每秒运行一次回调函数，进行计数，当回调函数执行了 10 次时，通知主线程。主线程打印 worker 线程运行时间。</p>
<p>代码运行结果如图3.1所示<br>
<img src="https://aiyou.life/post-images/1573401585223.png" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">图 3.1</div>
<p>运行结果并不符合预期。预期结果应当是<strong>Worker线程任务内部耗时</strong>与<strong>Worker线程任务耗时</strong>相差不多。出现这个结果的原因在于js代码在执行到<code>worker.postMessage(10)</code>时,并没有通知到Worker开始工作，而是等待当前任务队列执行完毕，才开始调用 Worker😭..这里不像fetch函数那样，代码执行到fetch时,浏览器另开线程去处理请求，拿到结果再进行回调,其他代码接着运行。</p>
<p>那么问题又来了,worker是属于宏任务还是微任务呢?<br>
验证代码如下:</p>
<pre><code class="language-javascript">...
setTimeout(()=&gt;{
    console.log('SetTimeout')
}, 0)
const worker = createWorker(function () {
    onmessage = function(e) {
    console.log('进入WebWorker ')
    let count = 1
    let startTime = Date.now()
    let timer = setInterval(function () {
            if (count++ === e.data) {
                clearInterval(timer)
                postMessage(startTime)
            }
        }, 1000)
    }
})
...
</code></pre>
<div style="text-align:center;font-size:80%">代码 3.2</div>
<p>运行结果如下:<br>
<img src="https://aiyou.life/post-images/1573403893208.png" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">图 3.2</div>
<p><code>SetTimeout</code>在<code>进入WebWorker</code>之前输出,说明<strong>Worker是宏任务</strong></p>
<h2 id="4-更进一步">4. 更进一步</h2>
<p>上一节中,我们考虑将计时器函数丢到Worker中去执行.但实际运行结果并不符合预期。那我们换一种思路，将主线程耗时任务丢到Worker执行，计时器精度会提高吗?答案是肯定的<br>
看如下代码4.1:</p>
<pre><code class="language-javascript">const startTime = Date.now()
setTimeout(function () {
    console.log('task finished after ' + (Date.now() - startTime) + 'ms')
}, 0)
// 将代码2.1中的耗时任务放到worker
const createWorker = (fn, options) =&gt; {
    const blob = new Blob(['(' + fn.toString() + ')()']);
    const url = URL.createObjectURL(blob);
    if (options) {
        return new Worker(url, options);
    }
    return new Worker(url);
}
const worker = createWorker(function () {
    const startTime = Date.now()
    for (let i = 0; i &lt; 9000; i++) {
        console.log(5 + 8 + 8 + 8)
        if (i === 9000 - 1) {
            postMessage(startTime)
        }
    }
})
worker.postMessage('start')
worker.onmessage = function (e) {
    console.log('Worker线程任务内部耗时:' + (Date.now() - e.data) + 'ms')
    console.log('Worker线程任务耗时:'+ (Date.now() - startTime) + 'ms')
    this.terminate()
}
</code></pre>
<div style="text-align:center;font-size:80%">代码 4.1</div>
<p>运行结果如图4.1:<br>
<img src="https://aiyou.life/post-images/1573437200815.png" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">图 4.1</div>
<p>对比上文代码2.1,可以看到计时器精度提高了不少。</p>
<p>将Worker替换成setTimeout试试</p>
<pre><code class="language-javascript">const startTime = Date.now()
setTimeout(function () {
    console.log('task finished after ' + (Date.now() - startTime) + 'ms')
}, 0)
// 将代码2.1中耗时任务放到setTimeout中
setTimeout(function () {
    for (let i = 0 ; i &lt; 9000 ; i++) {
        console.log(5 + 8 + 8 + 8)
    }
    console.log('主线程复杂任务耗时:' + (Date.now() - startTime) + 'ms')
}, 0)
</code></pre>
<div style="text-align:center;font-size:80%">代码 4.2</div>
<p>运行结果如图4.2:<br>
<img src="https://aiyou.life/post-images/1573808921223.png" alt="" loading="lazy"></p>
<div style="text-align:center;font-size:80%">图 4.2</div>
<p>对比上文代码2.1,可以看到计时器精度也提高了不少。</p>
<p><strong>总结</strong>:<em>主线程遇到耗时任务，应当考虑将其丢到下一个宏任务中去执行，这样不会阻塞当前任务队列的执行。题目中讲到要提高计时器函数精度，实际计时器也是一个宏任务。计时器与耗时任务在丢到下一个任务队列，要保证计时器任务在前，这样就可以提高计时器精度。再者，计时器函数要尽量靠前，先于其他代码执行，因为代码执行本身也会消耗时间</em>。</p>
<h2 id="5-最佳实战">5. 最佳实战</h2>
<p>主线程遇到无关DOM的耗时任务时，应当首先考虑使用Worker进行处理与计算。这样才不会阻塞主线程。代码4.2中，我们尝试将耗时任务放到主线程的中的下一个宏任务队列中，如果任务有上万数据进行计算，还是会阻塞主线程。Worker虽然属于宏任务，但只是将数据传输到Worker线程，由Worker进行计算。计算完成后，通知主线程。</p>
<h2 id="6-实现一个相对精确的setinterval">6. 实现一个相对精确的setInterval</h2>
<pre><code class="language-javascript">function loop(fn, interval) {
    const startTime = Date.now()
    let count = 0
    let currentInterval = interval
    let timer = 0
    function inner() {
        count++
        let offset = new Date().getTime() - (startTime + count * interval)
        currentInterval = interval - offset
        console.log('代码执行时间：' + offset, '下次循环间隔' + currentInterval)
        timer = setTimeout(inner, currentInterval)
        fn(timer)
    }
    setTimeout(inner, currentInterval)
}

let count = 0
loop(function (timer) {
    console.log('外部函数')
    if (count++ === 10) {
        console.log('外部函数执行完毕')
        clearTimeout(timer)
    }
}, 1000)
</code></pre>
<p>如上代码,我们构造了一个与<code>setInterval</code>函数功能类似的loop函数。插入主线程的任务的时间排除了代码的执行时间,相对于setInterval精度提高了很多。但当代码的执行时间大于设定的t时,主线程插入任务时间也不会准。</p>
<h2 id="7-后记">7. 后记</h2>
<p>这个问题来自于公众号上看到的某大厂的面试题。因而引发了一系列思考与探讨，顺便研究了一下WebWorker。其实提高setTimeout与setInterval计时精确度本身是一件无意义的事情，实际中本就没有这样的应用场景，但探索的过程还是蛮有意义的(就是有点耗费头发😭)。。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用Gridea生成GitHubPage静态博客]]></title>
        <id>https://aiyou.life/post/uhJjH7paD/</id>
        <link href="https://aiyou.life/post/uhJjH7paD/">
        </link>
        <updated>2019-11-07T00:30:44.000Z</updated>
        <summary type="html"><![CDATA[<p>无意间发现了这么一个项目，感觉很好很强大，因而研究了一下，搭建了基于Gridea和GitHubPage的静态博客。现将搭建过程记录，以飨读者。</p>
]]></summary>
        <content type="html"><![CDATA[<p>无意间发现了这么一个项目，感觉很好很强大，因而研究了一下，搭建了基于Gridea和GitHubPage的静态博客。现将搭建过程记录，以飨读者。</p>
<!-- more -->
<h2 id="1-概念与原理">1. 概念与原理</h2>
<h3 id="11-github">1.1 GitHub</h3>
<p><a href="https://github.com/">GitHub</a>是一个面向开源及私有软件项目的托管平台。通俗点来说像一个网盘，办公室将代码推到GitHub，回家之后再拉下来，然后就可以接着工作了。除此之外，可以多人协作完成一个项目，项目成员提交的代码互相之间都可以看到并进行合并与修改，项目成员之外的人也可以fork一份代码，修改代码之后, PR(Pull Request)到项目分支，项目管理员选择合并与否。</p>
<p>学习资料:</p>
<blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/20070065/answer/117017972">GitHub怎么用</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">Git操作命令</a></li>
</ul>
</blockquote>
<h3 id="12-github-page">1.2 GitHub Page</h3>
<p>GitHub Page 是 GitHub 公司推出的网页服务。GitHub会分配一个域名到你的仓库(eg:<a href="https://github.com/LuckyHH/LuckyHH.github.io">我的仓库</a>被分配的域名为: LuckyHH.github.io),通过该域名就可以访问到你的项目。此时，仓库其实就是一个静态资源服务器了。</p>
<h3 id="13-gridea">1.3 Gridea</h3>
<p>Gridea 是一个写作客户端。是类似生成器之类的东西，在 Gridea 上写完文章之后，会将各种资源文件生成并同步到 GitHub仓库上，通过域名访问到的就是美化后的页面了。<br>
类似的服务还有大名鼎鼎的 <a href="https://hexo.io/">Hexo</a> 和 <a href="http://jekyllcn.com/">Jekyll</a>.只不过他俩需要通过命令去生成和推文件，不如 Gridea 方便。</p>
<h2 id="2-实践">2. 实践</h2>
<p>其实 Gridea 作者自己录了视频，我看了一下还挺详细的。这里就不长篇大论了。</p>
<p><a href="https://gridea.dev/">Gridea下载地址</a><br>
<a href="https://space.bilibili.com/328305121/channel/detail?cid=75167">视频地址在这里</a></p>
<h2 id="3-自定义域名">3. 自定义域名</h2>
<p>通过 GitHub 分配的域名就可以访问到博客了。如果使用自定义域名，请看本节，否则跳过。</p>
<h3 id="31-域名准备">3.1 域名准备</h3>
<p>首先准备一个域名。可以到<a href="https://wanwang.aliyun.com/">阿里云</a>或者<a href="https://dnspod.cloud.tencent.com/">腾讯云</a>随便买一个即可，域名不需要备案。推荐到阿里云购买。<br>
其实也有很多国外公司提供的免费域名(eg:<a href="https://www.freenom.com/zh/index.html?lang=zh">Freenom</a>)，但大都只有一年的免费使用时间，续费还挺贵的。</p>
<h3 id="32-域名解析">3.2 域名解析</h3>
<p>将域名解析到GitHub的服务器<br>
[阿里云]<br>
打开阿里云<a href="https://dns.console.aliyun.com/">域名解析控制面板</a>并点击<strong>解析设置</strong><br>
<img src="https://aiyou.life/post-images/1573091513244.png" alt="" loading="lazy"></p>
<div style="text-align:center;">图 3.2.1</div>
<p>点击<strong>添加记录</strong>，在弹出的框中,如图 3.2.3 中箭头部分输入 图 3.2.2 中框出的记录值，其他默认。点击<strong>确定</strong>即可<br>
<img src="https://aiyou.life/post-images/1573091750777.png" alt="" loading="lazy"></p>
<div style="text-align:center;">图 3.2.2</div>
<figure data-type="image" tabindex="1"><img src="https://aiyou.life/post-images/1573092227894.png" alt="" loading="lazy"></figure>
<div style="text-align:center;">图 3.2.3</div>
<p>[腾讯云]<br>
打开腾讯云<a href="https://console.cloud.tencent.com/cns">域名解析控制面板</a>并点击<strong>解析</strong><br>
<img src="https://aiyou.life/post-images/1573092569137.png" alt="" loading="lazy"></p>
<div style="text-align:center;">图 3.2.4</div>
<p>点击<strong>添加记录</strong>,在输入框中按图 3.2.5 输入即可。进行四次添加记录操作，记录值分别填入 图 3.2.2中框出的记录值<br>
<img src="https://aiyou.life/post-images/1573092703412.png" alt="" loading="lazy"></p>
<div style="text-align:center;">图 3.2.5</div>
<h3 id="33-gridea配置">3.3 Gridea配置</h3>
<p>在软件上添加记录即可<br>
<img src="https://aiyou.life/post-images/1573093078100.png" alt="" loading="lazy"></p>
<div style="text-align:center;">图 3.3.1</div>
<h2 id="4-注意">4. 注意</h2>
<blockquote>
<ul>
<li>GitHub的服务器在国外，所以博客访问速度会很慢，挂个VPN访问会快很多</li>
<li>每次在Gridea同步完修改之后，需要等待几分钟网页才会有变化，这是GitHub服务器缓存导致的，无解</li>
</ul>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TS中函数传参绕过编译器检查的探究]]></title>
        <id>https://aiyou.life/post/aanhFpuGI/</id>
        <link href="https://aiyou.life/post/aanhFpuGI/">
        </link>
        <updated>2019-11-05T10:32:32.000Z</updated>
        <summary type="html"><![CDATA[<p>在TypeScript中文网接口一章中，对于函数传参<strong>为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查</strong> 的原因只给了一个简单的回答:&quot;因为 squareOptions不会经过额外属性检查，所以编译器不会报错&quot;.解释的如此简单，让人迷糊。本文将对这个问题进行探究。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在TypeScript中文网接口一章中，对于函数传参<strong>为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查</strong> 的原因只给了一个简单的回答:&quot;因为 squareOptions不会经过额外属性检查，所以编译器不会报错&quot;.解释的如此简单，让人迷糊。本文将对这个问题进行探究。</p>
<!-- more -->
<h2 id="缘起">缘起</h2>
<p>问题源于TypeScript中<a href="https://www.tslang.cn/docs/handbook/interfaces.html">接口</a>一章额外的类型检查一节关于最后一种绕过编译器检查的描述</p>
<p>原问题请查看<a href="https://segmentfault.com/q/1010000018219694?_ea=7267273">TypeScript绕过编译器检查的一点困惑</a></p>
<p>先看示例代码</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: &quot;white&quot;, area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

[标注1]
createSquare({ color: 'red', width: 100, height: 12 });    // 错误

let param = { height: 200, width: 100, color: 'red' };

createSquare(param);    // 正确

[标注2]
let param = {}

createSquare(param)  // 正确

let param1 = { height: 200 }

createSquare(param1)  // 错误

let param2 = { height: 200 } as SquareConfig

createSquare(param2)  // 正确

let param3 = { height: 200, color: &quot;red&quot; }

createSquare(param3)  // 正确

</code></pre>
<p>原文中对 <strong>为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查</strong> 的原因只给了一个简单的回答:&quot;因为 squareOptions不会经过额外属性检查，所以编译器不会报错&quot;.解释的如此简单，让人迷糊。</p>
<p>这里引出两个问题:</p>
<p>1.看 标注1 代码。为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查。而直接将对象作为参数传递到函数就会引起错误？</p>
<p>2.看 标注2 代码。对比来看，为什么传入 param1 参数就会引起错误？</p>
<h2 id="解题思路">解题思路</h2>
<p>首先看代码中的函数</p>
<pre><code class="language-typescript">function createSquare(config: SquareConfig): {color: string; area: number} {
  ...
}
</code></pre>
<p>函数要求我们传入的参数是 SquareConfig 类型的。</p>
<p>函数参数<code>{color: &quot;red&quot;, width: 100 }</code>可以定义为合法的 SquareConfig 类型，所以是正确的</p>
<p>函数参数<code>{color: &quot;red&quot;, width: 100, height: 100 }</code>不可以定义为合法的 SquareConfig 类型，所以引起错误</p>
<p>对上面的描述感觉迷糊的话，请接着往下看...</p>
<p>再看下面的代码</p>
<pre><code class="language-typescript">const test1:SquareConfig = {  // 正确
  color: &quot;red&quot;,
  width: 100
}

const test2:SquareConfig = {   // 出错
  color: &quot;red&quot;,
  width: 100,
  height: 100
}
</code></pre>
<p>代码很简单，也很容易明白为什么。SquareConfig 只定义 color 和 width, 传入 height 肯定出错。。</p>
<p><code>function createSquare(config: SquareConfig)</code>括号中实际进行了一次定义变量的过程,相当于如下代码:</p>
<pre><code class="language-typescript">const t: SquareConfig = config
function createSquare(t){
  ...
}
</code></pre>
<p>所以，当函数中传参 <code>{ color: 'red', width: 100, height: 12 }</code>时</p>
<p>定义变量都没走通的话，那肯定会报错啦</p>
<p>那为什么将一个对象赋值给一个另一个变量，再将变量传入函数就正确了呢?接着往下看</p>
<p>其实就是 object 转换为 SquareConfig 的问题。具体的内容还需要学习一下 类型兼容 那一章节,没看到那里，就先不具体聊了。</p>
<pre><code class="language-typescript">let a1 = {}
let t1: SquareConfig = a1   // 正确
createSquare(t1)

let a2 = { width: 10}
let t2: SquareConfig = a2   // 正确
createSquare(t2)

let a3 = { height: 10 }
let t3: SquareConfig = a3   // 错误
createSquare(t3)

let a4 = { width: 10, color: &quot;red&quot;}
let t4: SquareConfig = a4   // 正确
createSquare(t4)

let a5 = { width: 10, color: &quot;red&quot;, height: 10}
let t5: SquareConfig = a5   // 正确
createSquare(t5)
</code></pre>
<p>转化要求 类型兼容。object 与 SquareConfig 类型兼容，所以可以转化。转化成功与否在于 object 中是否有与 SquareConfig 公共项。</p>
<p>至此就解释通了 标注1 和标注2 的问题啦.</p>
<h2 id="总结">总结</h2>
<p>研究过程中也是走了一些弯弯的，开始时以为是在 编译器在定义函数参数那里自动默认进行了 类型推断 ，但后来才发现 类型推断的话，有很多地方解释不通。比如下面这一段代码，后来在热心大佬的指导下，才明白了为什么。</p>
<pre><code class="language-typescript">let param1 = { height: 200 }

createSquare(param1)  // 错误

let param2 = { height: 200 } as SquareConfig

createSquare(param2)  // 正确
</code></pre>
<p><strong>实际写代码的过程中并不推荐使用这种 将一个对象赋值给一个另一个变量，再将变量传入函数 这种方式来达到向 函数内部传接口没定义的参数的目的。更推荐的写法如下所示</strong></p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: any;
}
</code></pre>
<p>加入<code>[propName: string]: any;</code> 表示接受任意类别参数。这样怎么传都是正确的，没有了上面那些&quot;坑&quot;</p>
]]></content>
    </entry>
</feed>