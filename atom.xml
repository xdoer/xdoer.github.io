<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aiyou.life</id>
    <title>文享日志</title>
    <updated>2019-11-11T10:29:17.823Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aiyou.life"/>
    <link rel="self" href="https://aiyou.life/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://aiyou.life/images/avatar.png</logo>
    <icon>https://aiyou.life/favicon.ico</icon>
    <rights>All rights reserved 2019, 文享日志</rights>
    <entry>
        <title type="html"><![CDATA[关于提高setTimeout与setInterval精确度的探索]]></title>
        <id>https://aiyou.life/post/kokne79MF</id>
        <link href="https://aiyou.life/post/kokne79MF">
        </link>
        <updated>2019-11-10T09:54:20.000Z</updated>
        <summary type="html"><![CDATA[<p>我们都知道，setTimeout与setInterval都不是精确的计时器，它还与当前主线程任务队列中的任务大小数量有关。当主线程任务队列的任务没有执行完毕时,setTimeout与setInterval就不会准确的在 t 时间后运行。那怎么才能提高二者的精确度呢?</p>
]]></summary>
        <content type="html"><![CDATA[<p>我们都知道，setTimeout与setInterval都不是精确的计时器，它还与当前主线程任务队列中的任务大小数量有关。当主线程任务队列的任务没有执行完毕时,setTimeout与setInterval就不会准确的在 t 时间后运行。那怎么才能提高二者的精确度呢?</p>
<!-- more -->
<h2 id="1-settimeoutsetinterval用法">1. setTimeout/setInterval用法</h2>
<p>这里还是简单提一嘴吧。这两个函数是定时器函数，setTimeout表示回调函数在 t 时间后运行，setInterval表示回调函数每隔 t 时间运行。</p>
<pre><code class="language-javascript">setTimeout(function(){
    ...
}, t)

setInterval(function(){
    ...
}, t)
</code></pre>
<div style="text-align:center;font-size:80%">代码 1.1</div>
<p>在 CSS3/HTML5之前，二者常用来绘制页面动画。CSS3/HTML5之后，常用css来绘制动画。另外还一个API是requestAnimationFrame. 该函数与setInterval类似，区别在于该函数没有 t 参数，默认是屏幕刷新的每帧调用一次。每秒调用（1/屏幕刷新率）次</p>
<pre><code class="language-javascript">requestAnimationFrame(function(){
    // DOM动画
})
</code></pre>
<div style="text-align:center;font-size:80%">代码 1.2</div>
<h2 id="2-发现问题">2. 发现问题</h2>
<p>Js是一个单线程语言，同一时间只能做同一件事情。这很好理解，如果同一时间能做多个任务，那么多任务都在操作DOM时，页面该怎么显示呢?因而JS设计为了单线程,但单线程也带来了一些问题，比如线程阻塞，CPU利用率不高等问题。看代码2.1</p>
<pre><code class="language-javascript">setTimeout(function () {
    console.log('task finished after ' + (Date.now() - startTime) + 'ms')
}, 0)

for (let i = 0 ; i &lt; 9000 ; i++) {
    console.log(5 + 8 + 8 + 8)
}
console.log('主线程复杂任务耗时:' + (Date.now() - startTime) + 'ms')
</code></pre>
<div style="text-align:center;font-size:80%">代码 2.1</div>
<p>执行结果如图 2.1 所示<br>
<img src="https://aiyou.life/post-images/1573436890372.png" alt=""></p>
<div style="text-align:center;font-size:80%">图 2.1</div>
<p>for循环是一个耗时任务,阻塞了setTimeout的执行。我们设定0秒后执行输出，可实际结果是在1243ms之后输出，所以setTimeout的 t 参数定时不够精确。</p>
<!-- **结论**: *主线程里实际上是没有办法精确按时执行setTimeout/setInterval的回调函数。当浏览器js引擎解析代码遇到 setTimeout/setInterval 时，会将他们注册到下一个宏任务队列，只有执行完当前宏任务队列和微任务队列中的任务后，才会执行下一个宏任务队列中的任务。代码的执行本身就消耗时间*。 -->
<p>关于事件循环、宏任务、微任务不是本文重点，感兴趣的可以看看这篇文章<a href="https://juejin.im/post/5bac87b6f265da0a906f78d8">笔试题——JavaScript事件循环机制（event loop、macrotask、microtask）</a></p>
<p>那么到底要怎么解决精确度问题呢?</p>
<h2 id="3-解决问题">3. 解决问题</h2>
<p>前文我们一直在提及主线程主线程的，那么有没有办法利用其它线程进行计时呢?当代码执行到特定位置，通知其它线程中开始计时任务，主线程继续完成复杂任务，那么线程就不会阻塞，这样的话计时精确度就提高了。那么问题来了，JS不是一门单线程语言吗，怎么能利用除了主线程之外的其他线程呢?</p>
<p>在HTML5中，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Worker">Worker</a>的引入使得我们有了利用其它线程的能力。注意:<strong>Worker中不能操作DOM</strong>。</p>
<p>事情好办了。洋洋洒洒写下如下代码:</p>
<pre><code class="language-javascript">// worker生成器
const createWorker = (fn, options) =&gt; {
    const blob = new Blob(['(' + fn.toString() + ')()']);
    const url = URL.createObjectURL(blob);
    if (options) {
        return new Worker(url, options);
    }
    return new Worker(url);
} 
// 生成worker
const worker = createWorker(function () {
    onmessage = function(e) {
        console.log('进入WebWorker')
        let count = 1
        let startTime = Date.now()
        let timer = setInterval(function () {
            if (count++ === e.data) {
                clearInterval(timer)
                postMessage(startTime)
            }
        }, 1000)
    }
})
// worker线程任务
const startTime = Date.now()
worker.postMessage(10)
worker.onmessage = function (e) {
    console.log('Worker线程任务内部耗时:' + (Date.now() - e.data) + 'ms')
    console.log('Worker线程任务耗时:'+ (Date.now() - startTime) + 'ms')
    this.terminate()
}
// 主线程任务
for (let i = 0 ; i &lt; 5000 ; i++) {
    console.log(5 + 8 + 8 + 8)
} 
console.log('主线程复杂任务耗时:' + (Date.now() - startTime) + 'ms')
</code></pre>
<div style="text-align:center;font-size:80%">代码 3.1</div>
<p>代码中, worker 线程每秒运行一次回调函数，进行计数，当回调函数执行了 10 次时，通知主线程。主线程打印 worker 线程运行时间。</p>
<p>代码运行结果如图3.1所示<br>
<img src="https://aiyou.life/post-images/1573401585223.png" alt=""></p>
<div style="text-align:center;font-size:80%">图 3.1</div>
<p>运行实例(查看console):</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="WebWorker" src="https://codepen.io/luckyhh/embed/bGGjVBg?height=265&theme-id=default&default-tab=js,result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href='https://codepen.io/luckyhh/pen/bGGjVBg'>WebWorker</a> by LuckyHH
  (<a href='https://codepen.io/luckyhh'>@luckyhh</a>) on <a href='https://codepen.io'>CodePen</a>.
</iframe>
<p>运行结果并不符合预期。预期结果应当是<strong>Worker线程任务内部耗时</strong>与<strong>Worker线程任务耗时</strong>保持一致，或相差不多。出现这个结果的原因在于js代码在执行到<code>worker.postMessage(10)</code>时,并没有通知到Worker开始工作，而是等待当前任务队列执行完毕，才开始调用 Worker😭..这里不像fetch函数那样，代码执行到fetch时,浏览器另开线程去处理请求，拿到结果再进行回调。</p>
<p>那么问题又来了,worker是属于宏任务还是微任务呢?<br>
验证代码如下:</p>
<pre><code class="language-javascript">...
setTimeout(()=&gt;{
    console.log('SetTimeout')
}, 1)
const worker = createWorker(function () {
    onmessage = function(e) {
    console.log('进入WebWorker ')
    let count = 1
    let startTime = Date.now()
    let timer = setInterval(function () {
        if (count++ === e.data) {
            clearInterval(timer)
            postMessage(startTime)
        }
    }, 1000)
    }
})
...
</code></pre>
<div style="text-align:center;font-size:80%">代码 3.2</div>
<p>运行结果如下:<br>
<img src="https://aiyou.life/post-images/1573403893208.png" alt=""></p>
<div style="text-align:center;font-size:80%">图 3.2</div>
<p><code>SetTimeout</code>在<code>进入WebWorker</code>之前输出,说明<strong>Worker是宏任务</strong></p>
<h2 id="4-更进一步">4. 更进一步</h2>
<p>上一节中,我们考虑将计时器函数丢到Worker中去执行.但实际运行结果并不符合预期。那我们换一种思路，将主线程耗时任务丢到Worker执行，计时器精度会提高吗?<br>
看如下代码4.1:</p>
<pre><code class="language-javascript">const startTime = Date.now()
setTimeout(function () {
    console.log('task finished after ' + (Date.now() - startTime) + 'ms')
}, 0)
const createWorker = (fn, options) =&gt; {
    const blob = new Blob(['(' + fn.toString() + ')()']);
    const url = URL.createObjectURL(blob);
    if (options) {
        return new Worker(url, options);
    }
    return new Worker(url);
}
const worker = createWorker(function () {
    const startTime = Date.now()
    for (let i = 0; i &lt; 9000; i++) {
        console.log(5 + 8 + 8 + 8)
        if (i === 9000 - 1) {
            postMessage(startTime)
        }
    }
})
worker.postMessage('start')
worker.onmessage = function (e) {
    console.log('Worker线程任务内部耗时:' + (Date.now() - e.data) + 'ms')
    console.log('Worker线程任务耗时:'+ (Date.now() - startTime) + 'ms')
    this.terminate()
}
</code></pre>
<div style="text-align:center;font-size:80%">代码 4.1</div>
<p>运行结果如图4.1:<br>
<img src="https://aiyou.life/post-images/1573437200815.png" alt=""></p>
<div style="text-align:center;font-size:80%">图 4.1</div>
<p>对比上文代码2.1,可以看到计时器精度提高了不少。</p>
<p>将Worker替换成setInterval试试</p>
<pre><code class="language-javascript">const startTime = Date.now()
setTimeout(function () {
    console.log('task finished after ' + (Date.now() - startTime) + 'ms')
}, 10)
let timer = setInterval(function(){
    for (let i = 0; i &lt; 9000; i++) {
        console.log(5 + 8 + 8 + 8)
        if (i === 9000 - 1) {
            clearInterval(timer)
            console.log('task2 finished after ' + (Date.now() - startTime) + 'ms')
        }
    }
}, 10)
</code></pre>
<div style="text-align:center;font-size:80%">代码 4.2</div>
<p>运行结果如图4.2:<br>
<img src="https://aiyou.life/post-images/1573438068318.png" alt=""></p>
<div style="text-align:center;font-size:80%">图 4.2</div>
<p>对比上文代码2.1,可以看到计时器精度也提高了不少。</p>
<p><strong>总结</strong>:<em>主线程遇到耗时任务，应当考虑将其丢到下一个宏任务中去执行，这样不会阻塞当前任务队列的执行。题目中讲到要提高计时器函数精度，实际计时器也是一个宏任务。计时器与耗时任务在丢到下一个任务队列，要保证计时器任务在前，这样就可以提高计时器精度。再者，计时器函数要尽量靠前，先于其他代码执行，因为代码执行本身也会消耗时间</em>。</p>
<h2 id="5-最佳实战">5. 最佳实战</h2>
<p>主线程遇到无关DOM的耗时任务时，应当首先考虑使用Worker进行处理与计算。这样才不会阻塞主线程。代码4.2中，我们尝试将耗时任务放到主线程的中的下一个宏任务队列中，如果任务有上万数据进行计算，还是会阻塞主线程。Worker虽然属于宏任务，但只是将数据传输到Worker线程，由Worker进行计算。计算完成后，通知主线程。</p>
<h2 id="6-后记">6. 后记</h2>
<p>这个问题来自于公众号上看到的某大厂的面试题。因而引发了一系列思考与探讨，顺便研究了一下WebWorker。其实提高setTimeout与setInterval计时精确度本身是一件无意义的事情，实际中本就没有这样的应用场景，但探索的过程还是蛮有意义的(就是有点耗费头发😭)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用Gridea生成GitHubPage静态博客]]></title>
        <id>https://aiyou.life/post/uhJjH7paD</id>
        <link href="https://aiyou.life/post/uhJjH7paD">
        </link>
        <updated>2019-11-07T00:30:44.000Z</updated>
        <summary type="html"><![CDATA[<p>无意间发现了这么一个项目，感觉很好很强大，因而研究了一下，搭建了基于Gridea和GitHubPage的静态博客。现将搭建过程记录，以飨读者。</p>
]]></summary>
        <content type="html"><![CDATA[<p>无意间发现了这么一个项目，感觉很好很强大，因而研究了一下，搭建了基于Gridea和GitHubPage的静态博客。现将搭建过程记录，以飨读者。</p>
<!-- more -->
<h2 id="1-概念与原理">1. 概念与原理</h2>
<h3 id="11-github">1.1 GitHub</h3>
<p><a href="https://github.com/">GitHub</a>是一个面向开源及私有软件项目的托管平台。通俗点来说像一个网盘，办公室将代码推到GitHub，回家之后再拉下来，然后就可以接着工作了。除此之外，可以多人协作完成一个项目，项目成员提交的代码互相之间都可以看到并进行合并与修改，项目成员之外的人也可以fork一份代码，修改代码之后, PR(Pull Request)到项目分支，项目管理员选择合并与否。</p>
<p>学习资料:</p>
<blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/20070065/answer/117017972">GitHub怎么用</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">Git操作命令</a></li>
</ul>
</blockquote>
<h3 id="12-github-page">1.2 GitHub Page</h3>
<p>GitHub Page 是 GitHub 公司推出的网页服务。GitHub会分配一个域名到你的仓库(eg:<a href="https://github.com/LuckyHH/LuckyHH.github.io">我的仓库</a>被分配的域名为: LuckyHH.github.io),通过该域名就可以访问到你的项目。此时，仓库其实就是一个静态资源服务器了。</p>
<h3 id="13-gridea">1.3 Gridea</h3>
<p>Gridea 是一个写作客户端。是类似生成器之类的东西，在 Gridea 上写完文章之后，会将各种资源文件生成并同步到 GitHub仓库上，通过域名访问到的就是美化后的页面了。<br>
类似的服务还有大名鼎鼎的 <a href="https://hexo.io/">Hexo</a> 和 <a href="http://jekyllcn.com/">Jekyll</a>.只不过他俩需要通过命令去生成和推文件，不如 Gridea 方便。</p>
<h2 id="2-实践">2. 实践</h2>
<p>其实 Gridea 作者自己录了视频，我看了一下还挺详细的。这里就不长篇大论了。</p>
<p><a href="https://gridea.dev/">Gridea下载地址</a><br>
<a href="https://space.bilibili.com/328305121/channel/detail?cid=75167">视频地址在这里</a></p>
<h2 id="3-自定义域名">3. 自定义域名</h2>
<p>通过 GitHub 分配的域名就可以访问到博客了。如果使用自定义域名，请看本节，否则跳过。</p>
<h3 id="31-域名准备">3.1 域名准备</h3>
<p>首先准备一个域名。可以到<a href="https://wanwang.aliyun.com/">阿里云</a>或者<a href="https://dnspod.cloud.tencent.com/">腾讯云</a>随便买一个即可，域名不需要备案。推荐到阿里云购买。<br>
其实也有很多国外公司提供的免费域名(eg:<a href="https://www.freenom.com/zh/index.html?lang=zh">Freenom</a>)，但大都只有一年的免费使用时间，续费还挺贵的。</p>
<h3 id="32-域名解析">3.2 域名解析</h3>
<p>将域名解析到GitHub的服务器<br>
[阿里云]<br>
打开阿里云<a href="https://dns.console.aliyun.com/">域名解析控制面板</a>并点击<strong>解析设置</strong><br>
<img src="https://aiyou.life/post-images/1573091513244.png" alt=""></p>
<div style="text-align:center;">图 3.2.1</div>
<p>点击<strong>添加记录</strong>，在弹出的框中,如图 3.2.3 中箭头部分输入 图 3.2.2 中框出的记录值，其他默认。点击<strong>确定</strong>即可<br>
<img src="https://aiyou.life/post-images/1573091750777.png" alt=""></p>
<div style="text-align:center;">图 3.2.2</div>
<figure data-type="image" tabindex="1"><img src="https://aiyou.life/post-images/1573092227894.png" alt=""></figure>
<div style="text-align:center;">图 3.2.3</div>
<p>[腾讯云]<br>
打开腾讯云<a href="https://console.cloud.tencent.com/cns">域名解析控制面板</a>并点击<strong>解析</strong><br>
<img src="https://aiyou.life/post-images/1573092569137.png" alt=""></p>
<div style="text-align:center;">图 3.2.4</div>
<p>点击<strong>添加记录</strong>,在输入框中按图 3.2.5 输入即可。进行四次添加记录操作，记录值分别填入 图 3.2.2中框出的记录值<br>
<img src="https://aiyou.life/post-images/1573092703412.png" alt=""></p>
<div style="text-align:center;">图 3.2.5</div>
<h3 id="33-gridea配置">3.3 Gridea配置</h3>
<p>在软件上添加记录即可<br>
<img src="https://aiyou.life/post-images/1573093078100.png" alt=""></p>
<div style="text-align:center;">图 3.3.1</div>
<h2 id="4-注意">4. 注意</h2>
<blockquote>
<ul>
<li>GitHub的服务器在国外，所以博客访问速度会很慢，挂个VPN访问会快很多</li>
<li>每次在Gridea同步完修改之后，需要等待几分钟网页才会有变化，这是GitHub服务器缓存导致的，无解</li>
</ul>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数参数绕过编译器检查的探究]]></title>
        <id>https://aiyou.life/post/kokne79MA</id>
        <link href="https://aiyou.life/post/kokne79MA">
        </link>
        <updated>2019-11-05T12:34:17.000Z</updated>
        <summary type="html"><![CDATA[<p>在TypeScript中文网接口一章中，对于函数传参<strong>为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查</strong> 的原因只给了一个简单的回答:&quot;因为 squareOptions不会经过额外属性检查，所以编译器不会报错&quot;.解释的如此简单，让人迷糊。本文将对这个问题进行探究。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在TypeScript中文网接口一章中，对于函数传参<strong>为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查</strong> 的原因只给了一个简单的回答:&quot;因为 squareOptions不会经过额外属性检查，所以编译器不会报错&quot;.解释的如此简单，让人迷糊。本文将对这个问题进行探究。</p>
<!-- more -->
<h2 id="缘起">缘起</h2>
<p>问题源于TypeScript中<a href="https://www.tslang.cn/docs/handbook/interfaces.html">接口</a>一章额外的类型检查一节关于最后一种绕过编译器检查的描述</p>
<p>原问题请查看<a href="https://segmentfault.com/q/1010000018219694?_ea=7267273">TypeScript绕过编译器检查的一点困惑</a></p>
<p>先看示例代码</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: &quot;white&quot;, area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

[标注1]
createSquare({ color: 'red', width: 100, height: 12 });    // 错误

let param = { height: 200, width: 100, color: 'red' };

createSquare(param);    // 正确

[标注2]
let param = {}

createSquare(param)  // 正确

let param1 = { height: 200 }

createSquare(param1)  // 错误

let param2 = { height: 200 } as SquareConfig

createSquare(param2)  // 正确

let param3 = { height: 200, color: &quot;red&quot; }

createSquare(param3)  // 正确

</code></pre>
<p>原文中对 <strong>为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查</strong> 的原因只给了一个简单的回答:&quot;因为 squareOptions不会经过额外属性检查，所以编译器不会报错&quot;.解释的如此简单，让人迷糊。</p>
<p>这里引出两个问题:</p>
<p>1.看 标注1 代码。为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查。而直接将对象作为参数传递到函数就会引起错误？</p>
<p>2.看 标注2 代码。对比来看，为什么传入 param1 参数就会引起错误？</p>
<h2 id="解题思路">解题思路</h2>
<p>首先看代码中的函数</p>
<pre><code class="language-typescript">function createSquare(config: SquareConfig): {color: string; area: number} {
  ...
}
</code></pre>
<p>函数要求我们传入的参数是 SquareConfig 类型的。</p>
<p>函数参数<code>{color: &quot;red&quot;, width: 100 }</code>可以定义为合法的 SquareConfig 类型，所以是正确的</p>
<p>函数参数<code>{color: &quot;red&quot;, width: 100, height: 100 }</code>不可以定义为合法的 SquareConfig 类型，所以引起错误</p>
<p>对上面的描述感觉迷糊的话，请接着往下看...</p>
<p>再看下面的代码</p>
<pre><code class="language-typescript">const test1:SquareConfig = {  // 正确
  color: &quot;red&quot;,
  width: 100
}

const test2:SquareConfig = {   // 出错
  color: &quot;red&quot;,
  width: 100,
  height: 100
}
</code></pre>
<p>代码很简单，也很容易明白为什么。SquareConfig 只定义 color 和 width, 传入 height 肯定出错。。</p>
<p><code>function createSquare(config: SquareConfig)</code>括号中实际进行了一次定义变量的过程,相当于如下代码:</p>
<pre><code class="language-typescript">const t: SquareConfig = config
function createSquare(t){
  ...
}
</code></pre>
<p>所以，当函数中传参 <code>{ color: 'red', width: 100, height: 12 }</code>时</p>
<p>定义变量都没走通的话，那肯定会报错啦</p>
<p>那为什么将一个对象赋值给一个另一个变量，再将变量传入函数就正确了呢?接着往下看</p>
<p>其实就是 object 转换为 SquareConfig 的问题。具体的内容还需要学习一下 类型兼容 那一章节,没看到那里，就先不具体聊了。</p>
<pre><code class="language-typescript">let a1 = {}
let t1: SquareConfig = a1   // 正确
createSquare(t1)

let a2 = { width: 10}
let t2: SquareConfig = a2   // 正确
createSquare(t2)

let a3 = { height: 10 }
let t3: SquareConfig = a3   // 错误
createSquare(t3)

let a4 = { width: 10, color: &quot;red&quot;}
let t4: SquareConfig = a4   // 正确
createSquare(t4)

let a5 = { width: 10, color: &quot;red&quot;, height: 10}
let t5: SquareConfig = a5   // 正确
createSquare(t5)
</code></pre>
<p>转化要求 类型兼容。object 与 SquareConfig 类型兼容，所以可以转化。转化成功与否在于 object 中是否有与 SquareConfig 公共项。</p>
<p>至此就解释通了 标注1 和标注2 的问题啦.</p>
<h2 id="总结">总结</h2>
<p>研究过程中也是走了一些弯弯的，开始时以为是在 编译器在定义函数参数那里自动默认进行了 类型推断 ，但后来才发现 类型推断的话，有很多地方解释不通。比如下面这一段代码，后来在热心大佬的指导下，才明白了为什么。</p>
<pre><code class="language-typescript">let param1 = { height: 200 }

createSquare(param1)  // 错误

let param2 = { height: 200 } as SquareConfig

createSquare(param2)  // 正确
</code></pre>
<p><strong>实际写代码的过程中并不推荐使用这种 将一个对象赋值给一个另一个变量，再将变量传入函数 这种方式来达到向 函数内部传接口没定义的参数的目的。更推荐的写法如下所示</strong></p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: any;
}
</code></pre>
<p>加入<code>[propName: string]: any;</code> 表示接受任意类别参数。这样怎么传都是正确的，没有了上面那些&quot;坑&quot;</p>
]]></content>
    </entry>
</feed>