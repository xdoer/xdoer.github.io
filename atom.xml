<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://aiyou.life</id>
    <title>文享日志</title>
    <updated>2019-11-07T02:25:55.156Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://aiyou.life"/>
    <link rel="self" href="https://aiyou.life/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://aiyou.life/images/avatar.png</logo>
    <icon>https://aiyou.life/favicon.ico</icon>
    <rights>All rights reserved 2019, 文享日志</rights>
    <entry>
        <title type="html"><![CDATA[Gridea生成你的静态博客站]]></title>
        <id>https://aiyou.life/post/uhJjH7paD</id>
        <link href="https://aiyou.life/post/uhJjH7paD">
        </link>
        <updated>2019-11-07T00:30:44.000Z</updated>
        <summary type="html"><![CDATA[<p>无意间发现了这么一个项目，感觉很好很强大，因而研究了一下，搭建了基于Gridea和GitHubPage的静态博客。现将搭建过程记录，以飨读者。</p>
]]></summary>
        <content type="html"><![CDATA[<p>无意间发现了这么一个项目，感觉很好很强大，因而研究了一下，搭建了基于Gridea和GitHubPage的静态博客。现将搭建过程记录，以飨读者。</p>
<!-- more -->
<h2 id="1-概念与原理">1. 概念与原理</h2>
<h3 id="11-github">1.1 GitHub</h3>
<p><a href="https://github.com/">GitHub</a>是一个面向开源及私有软件项目的托管平台。通俗点来说像一个网盘，办公室将代码推到GitHub，回家之后再拉下来，然后就可以接着工作了。除此之外，可以多人协作完成一个项目，项目成员提交的代码互相之间都可以看到并进行合并与修改，项目成员之外的人也可以fork一份代码，修改代码之后, PR(Pull Request)到项目分支，项目管理员选择合并与否。</p>
<p>学习资料:</p>
<blockquote>
<ul>
<li><a href="https://www.zhihu.com/question/20070065/answer/117017972">GitHub怎么用</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">Git操作命令</a></li>
</ul>
</blockquote>
<h3 id="12-github-page">1.2 GitHub Page</h3>
<p>GitHub Page 是 GitHub 公司推出的网页服务。GitHub会分配一个域名到你的仓库(eg:<a href="https://github.com/LuckyHH/LuckyHH.github.io">我的仓库</a>被分配的域名为: LuckyHH.github.io),通过该域名就可以访问到你的项目。此时，仓库其实就是一个静态资源服务器了。</p>
<h3 id="13-gridea">1.3 Gridea</h3>
<p>Gridea 是一个写作客户端。是类似生成器之类的东西，在 Gridea 上写完文章之后，会将各种资源文件生成并同步到 GitHub仓库上，通过域名访问到的就是美化后的页面了。<br>
类似的服务还有大名鼎鼎的 <a href="https://hexo.io/">Hexo</a> 和 <a href="http://jekyllcn.com/">Jekyll</a>.只不过他俩需要通过命名去生成和推文件，不如 Gridea 方便。</p>
<h2 id="2-实践">2. 实践</h2>
<p>其实 Gridea 作者自己录了视频，我看了一下还挺详细的。这里就不长篇大论了。</p>
<p><a href="https://gridea.dev/">Gridea下载地址</a><br>
<a href="https://space.bilibili.com/328305121/channel/detail?cid=75167">视频地址在这里</a></p>
<h2 id="3-自定义域名">3. 自定义域名</h2>
<p>通过 GitHub 分配的域名就可以访问到博客了。如果使用自定义域名，请看本节，否则跳过。</p>
<h3 id="31-域名准备">3.1 域名准备</h3>
<p>首先准备一个域名。可以到<a href="https://wanwang.aliyun.com/">阿里云</a>或者<a href="https://dnspod.cloud.tencent.com/">腾讯云</a>随便买一个即可，域名不需要备案。推荐到阿里云购买。<br>
其实也有很多国外公司提供的免费域名(eg:<a href="https://www.freenom.com/zh/index.html?lang=zh">Freenom</a>)，但大都只有一年的免费使用时间，续费还挺贵的。</p>
<h3 id="32-域名解析">3.2 域名解析</h3>
<p>将域名解析到GitHub的服务器<br>
[阿里云]<br>
打开阿里云<a href="https://dns.console.aliyun.com/">域名解析控制面板</a>并点击<strong>解析设置</strong><br>
<img src="https://aiyou.life/post-images/1573091513244.png" alt=""></p>
<div style="text-align:center;">图 3.2.1</div>
<p>点击<strong>添加记录</strong>，在弹出的框中,如图 3.2.3 中箭头部分输入 图 3.2.2 中框出的记录值，其他默认。点击<strong>确定</strong>即可<br>
<img src="https://aiyou.life/post-images/1573091750777.png" alt=""></p>
<div style="text-align:center;">图 3.2.2</div>
<figure data-type="image" tabindex="1"><img src="https://aiyou.life/post-images/1573092227894.png" alt=""></figure>
<div style="text-align:center;">图 3.2.3</div>
<p>[腾讯云]<br>
打开腾讯云<a href="https://console.cloud.tencent.com/cns">域名解析控制面板</a>并点击<strong>解析</strong><br>
<img src="https://aiyou.life/post-images/1573092569137.png" alt=""></p>
<div style="text-align:center;">图 3.2.4</div>
<p>点击<strong>添加记录</strong>,在输入框中按图 3.2.5 输入即可。进行四次添加记录操作，记录值分别填入 图 3.2.2中框出的记录值<br>
<img src="https://aiyou.life/post-images/1573092703412.png" alt=""></p>
<div style="text-align:center;">图 3.2.5</div>
<h3 id="33-gridea配置">3.3 Gridea配置</h3>
<p>在软件上添加记录即可<br>
<img src="https://aiyou.life/post-images/1573093078100.png" alt=""></p>
<div style="text-align:center;">图 3.3.1</div>
<h2 id="4-注意">4. 注意</h2>
<blockquote>
<ul>
<li>GitHub的服务器在国外，所以博客访问速度会很慢，挂个VPN访问会快很多</li>
<li>每次在Gridea同步完修改之后，需要等待几分钟网页才会有变化，这是GitHub服务器缓存导致的，无解</li>
</ul>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数参数绕过编译器检查的探究]]></title>
        <id>https://aiyou.life/post/han-shu-can-shu-rao-guo-bian-yi-qi-de-tan-jiu</id>
        <link href="https://aiyou.life/post/han-shu-can-shu-rao-guo-bian-yi-qi-de-tan-jiu">
        </link>
        <updated>2019-11-05T12:34:17.000Z</updated>
        <summary type="html"><![CDATA[<p>在TypeScript中文网接口一章中，对于函数传参<strong>为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查</strong> 的原因只给了一个简单的回答:&quot;因为 squareOptions不会经过额外属性检查，所以编译器不会报错&quot;.解释的如此简单，让人迷糊。本文将对这个问题进行探究。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在TypeScript中文网接口一章中，对于函数传参<strong>为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查</strong> 的原因只给了一个简单的回答:&quot;因为 squareOptions不会经过额外属性检查，所以编译器不会报错&quot;.解释的如此简单，让人迷糊。本文将对这个问题进行探究。</p>
<!-- more -->
<h2 id="缘起">缘起</h2>
<p>问题源于TypeScript中<a href="https://www.tslang.cn/docs/handbook/interfaces.html">接口</a>一章额外的类型检查一节关于最后一种绕过编译器检查的描述</p>
<p>原问题请查看<a href="https://segmentfault.com/q/1010000018219694?_ea=7267273">TypeScript绕过编译器检查的一点困惑</a></p>
<p>先看示例代码</p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: &quot;white&quot;, area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}

[标注1]
createSquare({ color: 'red', width: 100, height: 12 });    // 错误

let param = { height: 200, width: 100, color: 'red' };

createSquare(param);    // 正确

[标注2]
let param = {}

createSquare(param)  // 正确

let param1 = { height: 200 }

createSquare(param1)  // 错误

let param2 = { height: 200 } as SquareConfig

createSquare(param2)  // 正确

let param3 = { height: 200, color: &quot;red&quot; }

createSquare(param3)  // 正确

</code></pre>
<p>原文中对 <strong>为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查</strong> 的原因只给了一个简单的回答:&quot;因为 squareOptions不会经过额外属性检查，所以编译器不会报错&quot;.解释的如此简单，让人迷糊。</p>
<p>这里引出两个问题:</p>
<p>1.看 标注1 代码。为什么将一个对象赋值给一个另一个变量，再将变量传入函数就可以绕过编译器检查。而直接将对象作为参数传递到函数就会引起错误？</p>
<p>2.看 标注2 代码。对比来看，为什么传入 param1 参数就会引起错误？</p>
<h2 id="解题思路">解题思路</h2>
<p>首先看代码中的函数</p>
<pre><code class="language-typescript">function createSquare(config: SquareConfig): {color: string; area: number} {
  ...
}
</code></pre>
<p>函数要求我们传入的参数是 SquareConfig 类型的。</p>
<p>函数参数<code>{color: &quot;red&quot;, width: 100 }</code>可以定义为合法的 SquareConfig 类型，所以是正确的</p>
<p>函数参数<code>{color: &quot;red&quot;, width: 100, height: 100 }</code>不可以定义为合法的 SquareConfig 类型，所以引起错误</p>
<p>对上面的描述感觉迷糊的话，请接着往下看...</p>
<p>再看下面的代码</p>
<pre><code class="language-typescript">const test1:SquareConfig = {  // 正确
  color: &quot;red&quot;,
  width: 100
}

const test2:SquareConfig = {   // 出错
  color: &quot;red&quot;,
  width: 100,
  height: 100
}
</code></pre>
<p>代码很简单，也很容易明白为什么。SquareConfig 只定义 color 和 width, 传入 height 肯定出错。。</p>
<p><code>function createSquare(config: SquareConfig)</code>括号中实际进行了一次定义变量的过程,相当于如下代码:</p>
<pre><code class="language-typescript">const t: SquareConfig = config
function createSquare(t){
  ...
}
</code></pre>
<p>所以，当函数中传参 <code>{ color: 'red', width: 100, height: 12 }</code>时</p>
<p>定义变量都没走通的话，那肯定会报错啦</p>
<p>那为什么将一个对象赋值给一个另一个变量，再将变量传入函数就正确了呢?接着往下看</p>
<p>其实就是 object 转换为 SquareConfig 的问题。具体的内容还需要学习一下 类型兼容 那一章节,没看到那里，就先不具体聊了。</p>
<pre><code class="language-typescript">let a1 = {}
let t1: SquareConfig = a1   // 正确
createSquare(t1)

let a2 = { width: 10}
let t2: SquareConfig = a2   // 正确
createSquare(t2)

let a3 = { height: 10 }
let t3: SquareConfig = a3   // 错误
createSquare(t3)

let a4 = { width: 10, color: &quot;red&quot;}
let t4: SquareConfig = a4   // 正确
createSquare(t4)

let a5 = { width: 10, color: &quot;red&quot;, height: 10}
let t5: SquareConfig = a5   // 正确
createSquare(t5)
</code></pre>
<p>转化要求 类型兼容。object 与 SquareConfig 类型兼容，所以可以转化。转化成功与否在于 object 中是否有与 SquareConfig 公共项。</p>
<p>至此就解释通了 标注1 和标注2 的问题啦.</p>
<h2 id="总结">总结</h2>
<p>研究过程中也是走了一些弯弯的，开始时以为是在 编译器在定义函数参数那里自动默认进行了 类型推断 ，但后来才发现 类型推断的话，有很多地方解释不通。比如下面这一段代码，后来在热心大佬的指导下，才明白了为什么。</p>
<pre><code class="language-typescript">let param1 = { height: 200 }

createSquare(param1)  // 错误

let param2 = { height: 200 } as SquareConfig

createSquare(param2)  // 正确
</code></pre>
<p><strong>实际写代码的过程中并不推荐使用这种 将一个对象赋值给一个另一个变量，再将变量传入函数 这种方式来达到向 函数内部传接口没定义的参数的目的。更推荐的写法如下所示</strong></p>
<pre><code class="language-typescript">interface SquareConfig {
  color?: string;
  width?: number;
  [propName: string]: any;
}
</code></pre>
<p>加入<code>[propName: string]: any;</code> 表示接受任意类别参数。这样怎么传都是正确的，没有了上面那些&quot;坑&quot;</p>
]]></content>
    </entry>
</feed>